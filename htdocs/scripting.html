<HTML>
<HEAD>
  <!-- Created with AOLpress/2.0 -->
  <!-- AP: Created on: 18-Jan-2002 -->
  <!-- AP: Last modified: 3-Nov-2004 -->
  <TITLE>Writing scripts to change fonts in FontForge</TITLE>
  <LINK REL="icon" href="ffanvil16.png">
</HEAD>
<BODY>
<H1 ALIGN=Center>
  Writing scripts to change fonts in FontForge
</H1>
<P>
FontForge includes an interpreter so you can write scripts to modify fonts.
<UL>
  <LI>
    <A HREF="#Starting">Starting a script</A>
  <LI>
    <A HREF="#Language">Scripting language</A>
    <UL>
      <LI>
	<A HREF="#variables">Built in variables</A>
      <LI>
	<A HREF="#procedures">Built in procedures</A>
      <LI>
	<A HREF="#Example">Examples</A>
    </UL>
  <LI>
    <A HREF="scripting.html#Execute">The Execute Script dialog</A>
  <LI>
    <A HREF="#menu">The Scripts menu</A>
</UL>
<H2>
  <A NAME="Starting">Starting scripts</A>
</H2>
<P>
If you start fontforge with a script on the command line it will not put
up any windows and it will exit when the script is done.
<BLOCKQUOTE>
  <PRE>$ fontforge -script scriptfile.pe {fontnames}
</PRE>
</BLOCKQUOTE>
<P>
FontForge can also be used as an interpreter that the shell will automatically
pass scripts to. If you a mark your script files as executable<BR>
<CODE>&nbsp; &nbsp; $ chmod +x scriptfile.pe</CODE><BR>
and begin each one with the line<BR>
<CODE>&nbsp; &nbsp; #!/usr/local/bin/fontforge</CODE><BR>
(or wherever fontforge happens to reside on your system) then you can invoke
the script just by typing<BR>
<CODE>&nbsp; &nbsp; $ scriptfile.pe {fontnames}</CODE>
<P>
If you wish FontForge to read a script from stdin then you can use "-" as
a "filename" for stdin. (If you build FontForge without X11 then fontforge
will attempt to read a script file from <CODE>stdin</CODE> if none is given
on the command line.)
<P>
You can also start a script from within FontForge with
<CODE>File-&gt;Execute Script</CODE>, and you can use the Preference Dlg
to define a set of frequently used scripts which can be invoked directly
by menu.
<P>
The scripting language provides access to much of the functionality found
in the font view's menus. It does not currently (and probably never will)
provide access to everything. (If you find a lack let me know, I may put
it in for you). It does not provide commands for building up a glyph out
of splines, instead it allows you to do high level modifications to glyphs.
<P>
If you set the environment variable <CODE>PFAEDIT_VERBOSE</CODE> (it doesn't
need a value, just needs to be set) then FontForge will print scripts to
stdout as it executes them.
<P>
In general I envision this as being useful for things like taking a latin
font and extending it to contain cyrillic glyphs. So the script might:
<UL>
  <LI>
    Reencode the font
  <LI>
    Place a reference to Latin "A" at Cyrillic "A"
  <LI>
    Copy Latin "R" to Cyrillic "YA"
  <LI>
    Flip "YA" horizontally
  <LI>
    Correct its direction
  <LI>
    ... and so forth
</UL>
<H2>
  Scripting <A NAME="Language">Language</A>
</H2>
<P>
The syntax is rather like a mixture of C and shell commands. Every file
corresponds to a procedure. As in a shell script arguments passed to the
file are identified as $1, $2, ... $n. $0 is the file name itself. $argc
gives the number of arguments. $argv[&lt;expr&gt;] provides array access
to the arguments.
<P>
Terms can be
<UL>
  <LI>
    A variable name (like "$1" or "i" or "@fontvar" or "_global")<BR>
    The scope of the variable depends on the initial character of its name.
    <UL>
      <LI>
	A '$' signifies that it is a built-in variable. The user cannot create any
	new variables beginning with '$'. Some, but not all, of these may be assigned
	to.
      <LI>
	A '_' signifies that the variable is global, it is always available. You
	can use these to store context across different script files (or to access
	data within nested script files).
      <LI>
	A '@' signifies that the variable is associated with the font. Any two scripts
	looking at the same font will have access to the same variables.
      <LI>
	A variable which begins with a letter is a local variable. It is only meaningful
	within the current script file. Nested script files may have different variables
	with the same names.
    </UL>
  <LI>
    an integer expressed in decimal, hex or octal
  <LI>
    a unicode code point (which has a prefix of "0u" or "0U" and is followed
    by a string of hex digits. This is only used by the select command.
  <LI>
    A string which may be enclosed in either double or single quotes
  <LI>
    a procedure to call or file to invoke.
  <LI>
    an expression within parentheses
</UL>
<P>
There are three different comments supported:
<UL>
  <LI>
    Starting with a "#" character and proceeding to end of line
  <LI>
    Starting with "//" and proceeding to end of line
  <LI>
    Starting with "/*" and proceeding to "*/"
</UL>
<P>
Expressions are similar to those in C, a few operators have been omitted,
a few added from shell scripts. Operator precedence has been simplified slightly.
So operators (and their precedences) are:
<UL>
  <LI>
    unary operators (+, -, !, ~, ++ (prefix and postfix), --(prefix and postfix),
    () (procedure call), [] (array index), :h, :t, :r, :e<BR>
    Most of these are as expected in C, the last four are borrowed from shell
    scripts and are applied to strings
    <UL>
      <LI>
	:h gives the head (directory) of a pathspec
      <LI>
	:t gives the tail (filename) of a pathspec
      <LI>
	:r gives the pathspec without the extension (if any)
      <LI>
	:e gives the extension
    </UL>
  <LI>
    *, /, % (binary multiplicative operators)
  <LI>
    +, - (binary arithmetic operators)<BR>
    If the first operand of + is a string then + will be treated as concatenation
    rather than addition. If the second operand is a number it will be converted
    to a string (decimal representation) and then concatenated.
  <LI>
    ==, !=, &gt;, &lt;, &gt;=, &lt;= (comparison operators, may be applied to
    either two integers or two strings)
  <LI>
    &amp;&amp;, &amp; (logical and, bitwise and. (logical and will do short circuit
    evaluation))
  <LI>
    ||, |, ^ (logical or, bitwise or, bitwise exclusive or (logical or will do
    short circuit evaluation))
  <LI>
    =, +=, -=, *=, /=, %= (assignment operators as in C. The += will act as
    concatenation if the first operand is a string.)
</UL>
<P>
Note there is no comma operator, and no "?:" operator. The precedence of
"and" and "or" has been simplified, as has that of the assignment operators.
<P>
Procedure calls may be applied either to a name token, or to a string. If
the name or string is recognized as one of FontForge's internal procedures
it will be executed, otherwise it will be assumed to be a filename containing
another fontforge script file, this file will be invoked (since filenames
can contain characters not legal in name tokens it is important to allow
general strings to specify filenames). If the procedure name does not contain
a directory then it is assumed to be in the same directory as the current
script file.
<P>
Arrays are passed by reference, strings and integers are passed by value.
<P>
Variables may be created by assigning a value to them (only with the "="),
so:<BR>
<CODE>&nbsp; &nbsp; i=3</CODE><BR>
could be used to define "i" as a variable. Variables are limited in scope
to the current file, they will not be inherited by called procedures.
<P>
A statement may be
<UL>
  <LI>
    an expression
  <LI>
    <CODE>if ( expression )<BR>
    &nbsp; &nbsp; statements<BR>
    {elseif ( expression )<BR>
    &nbsp; &nbsp; statements}<BR>
    [else<BR>
    &nbsp; &nbsp; statements]<BR>
    endif</CODE>
  <LI>
    <CODE>while ( expression )<BR>
    &nbsp; &nbsp; statements<BR>
    endloop</CODE>
  <LI>
    <CODE>foreach<BR>
    &nbsp; &nbsp; statements<BR>
    endloop</CODE>
  <LI>
    <CODE>return [ expression ]</CODE>
  <LI>
    <CODE>shift</CODE>
</UL>
<P>
As with C, non-zero expressions are defined to be true.<BR>
A return statement may be followed by a return value (the expression) or
a procedure may return nothing (void).<BR>
The shift statement is stolen from shell scripts and shifts all arguments
down by one. (argument 0, the name of the script file, remains unchanged.<BR>
The foreach statement requires that there be a current font. It executes
the statements once for each glyph in the selection. Within the statements
only one glyph at a time will be selected. After execution the selection
will be restored to what it was initially. (Caveat: Don't reencode the font
within a foreach statement).<BR>
Statements are terminated either by a new line or a semicolon.
<P>
Trivial example:
<BLOCKQUOTE>
  <PRE>i=0;	#semicolon is not needed here, but it's ok
while ( i&lt;3 )
   if ( i==1 /* pointless comment */ )
	Print( "Got to one" )	// Another comment
   endif
   ++i
endloop
</PRE>
</BLOCKQUOTE>
<P>
FontForge maintains the concept of a "current font" almost all commands refer
only to the current font (and require that there be a font). If you start
a script with File-&gt;Execute Script, the font you were editing will be
current, otherwise there will be no initial current font. The Open(), New()
and Close() commands all change the current font. FontForge also maintains
a list of all fonts that are currently open. This list is in no particular
order. The list starts with $firstfont.
<P>
Similarly when working with cid keyed fonts, FontForge works in the "current
sub font", and most commands refer to this font. The CIDChangeSubFont() command
can alter that.
<P>
All builtin <A NAME="variables">variables</A> begin with "$", you may not
create any variables that start with "$" yourself (though you may assign
to (some) already existing ones)
<UL>
  <LI>
    <CODE>$0 </CODE>the current script filename
  <LI>
    <CODE>$1 </CODE>the first argument to the script file
  <LI>
    <CODE>$2 </CODE>the second argument to the script file
  <LI>
    ...
  <LI>
    <CODE>$argc</CODE> the number of arguments passed to the script file (this
    will always be at least 1 as $0 is always present)
  <LI>
    <CODE>$argv </CODE>allows you to access the array of all the arguments
  <LI>
    <CODE>$curfont </CODE>the name of the filename in which the current font
    resides
  <LI>
    <CODE>$firstfont </CODE>the name of the filename of the font which is first
    on the font list (Can be used by Open()), if there are no fonts loaded this
    returns an empty string. This can be used to determine if any font at all
    is loaded into fontforge.
  <LI>
    <CODE>$nextfont </CODE>the name of the filename of the font which follows
    the current font on the list (or the empty string if the current font is
    the last one on the list)
  <LI>
    <CODE>$fontchanged</CODE> returns 1 if the current font has changed, 0 if
    it has not changed since it was read in (or saved).
  <LI>
    <CODE>$fontname</CODE> the name contained in the postscript FontName field
  <LI>
    <CODE>$familyname </CODE>the name contained in the postscript FamilyName
    field
  <LI>
    <CODE>$fullname </CODE>the name contained in the postscript FullName field
  <LI>
    <CODE>$fondname </CODE>if set this name indicates what FOND the current font
    should be put in under Generate Mac Family.
  <LI>
    <CODE>$weight </CODE>the name contained in the postscript Weight field
  <LI>
    <CODE>$copyright </CODE>the name contained in the postscript Notice field
  <LI>
    <CODE>$filename </CODE>the name of the file containing the font.
  <LI>
    <CODE>$fontversion</CODE> the string containing the font's version
  <LI>
    <CODE>$cidfontname </CODE>returns the fontname of the top-level cid-keyed
    font (or the empty string if there is none)<BR>
    Can be used to detect if this is a cid keyed font.
  <LI>
    <CODE>$cidfamilyname, $cidfullname, $cidweight, $cidcopyright </CODE>similar
    to above
  <LI>
    <CODE>$mmcount </CODE>returns 0 for non multiple master fonts, returns the
    number of instances in a multiple master font.
  <LI>
    <CODE>$italicangle </CODE>the value of the postscript italic angle field
  <LI>
    <CODE>$curcid </CODE>returns the fontname of the current font
  <LI>
    <CODE>$firstcid </CODE>returns the fontname of the first font within this
    cid font
  <LI>
    <CODE>$nextcid </CODE>returns the fontname of the next font within this cid
    font (or the empty string if the current sub-font is the last)
  <LI>
    <CODE>$macstyle </CODE>returns the value of the macstyle field (a set of
    bits indicating whether the font is bold, italic, condensed, etc.)
  <LI>
    <CODE>$bitmaps </CODE>returns an array containing all bitmap pixelsizes generated
    for this font. (If the font database contains greymaps then they will be
    indicated in the array as
    <CODE>(&lt;BitmapDepth&gt;&lt;&lt;16)|&lt;PixelSize&gt;</CODE>)
  <LI>
    <CODE>$selection</CODE> returns an array containing one entry for each glyph
    in the current font indicating whether that glyph is selected or not
    (0=&gt;not, 1=&gt;selected)
  <LI>
    <CODE>$panose</CODE> returns an array containing the 10 panose values for
    the font.
  <LI>
    <CODE>$trace</CODE> if this is set to one then FontForge will trace each
    procedure call.
  <LI>
    <CODE>$version</CODE> returns a string containing the current version of
    fontforge. This should look something like "020817".
  <LI>
    <CODE>$</CODE>&lt;<A NAME="Preference">Preference</A> Item&gt; (for example
    <CODE>$AutoHint</CODE>) allows you to examine the value of that preference
    item (to set it use <CODE><A HREF="#SetPref">SetPref</A></CODE>)
</UL>
<P>
The following example will perform an action on all loaded fonts:
<BLOCKQUOTE>
  <PRE>file = $firstfont
while ( file != "" )
   Open(file)
   /* Do Stuff */
   file = $nextfont
endloop
</PRE>
</BLOCKQUOTE>
<P>
The built in <A NAME="procedures">procedures</A> are very similar to the
menu items with the same names.
<DL>
  <DT>
    Print(arg1,arg2,arg3,...)
  <DD>
    This corresponds to no menu item. It will print all of its arguments to stdout.
    It can execute with no current font.
  <DT>
    PostNotice(str)
  <DD>
    When run from the UI will put up a window displaying the string (the window
    will not block the program and will disappear after a minute or so). When
    run from the command line will write the string to stderr.
  <DT>
    Error(str)
  <DD>
    Prints out str as an error message and aborts the current script
  <DT>
    AskUser(question[,default-answer])
  <DD>
    Asks the user the question and returns an answer (a string). A default-answer
    may be specified too.
  <DT>
    Array(size)
  <DD>
    Allocates an array of the indicated size.
    <BLOCKQUOTE>
      <PRE>a = Array(10)
i = 0;
while ( i&lt;10 )
   a[i] = i++
endloop
a[3] = "string"
a[4] = Array(10)
a[4][0] = "Nested array";
</PRE>
    </BLOCKQUOTE>
  <DT>
    SizeOf(arr)
  <DD>
    Returns the number of elements in an array.
  <DT>
    Strsub(str,start[,end])
  <DD>
    Returns a substring of the string argument. The substring beings at position
    indexed by start and ends at the position indexed by end (if end is omitted
    the end of the string will be used, the first position is position 0). Thus
    <CODE>Strsub("abcdef",2,3) == "c" </CODE>and <CODE>Strsub("abcdef",2) ==
    "cdef"</CODE>
  <DT>
    Strlen(str)
  <DD>
    Returns the length of the string.
  <DT>
    Strstr(haystack,needle)
  <DD>
    Returns the index of the first occurrence of the string needle within the
    string haystack (or -1 if not found).
  <DT>
    Strrstr(haystack,needle)
  <DD>
    Returns the index of the last occurrence of the string needle within the
    string haystack (or -1 if not found).
  <DT>
    Strcasestr(haystack,needle)
  <DD>
    Returns the index of the first occurrence of the string needle within the
    string haystack ignoring case in the search (or -1 if not found).
  <DT>
    Strcasecmp(str1,str2)
  <DD>
    Compares the two strings ignoring case, returns zero if the two are equal,
    a negative number if str1&lt;str2 and a positive number if str1&gt;str2
  <DT>
    Strtol(str[,base])
  <DD>
    Parses as much of str as possible and returns the integer value it represents.
    A second argument may be used to specify the base of the conversion (it defaults
    to 10). Behavior is as for strtol(3).
  <DT>
    Strskipint(str[,base])
  <DD>
    Parses as much of str as possible and returns the offset to the first character
    that could not be parsed.
  <DT>
    LoadPrefs()
  <DD>
    Loads the user's preferences. This used to happen automatically at startup.
    Now it happens automatically when the UI is started, but scripts must request
    it.
  <DT>
    SavePrefs()
  <DD>
    Save the current state of preferences. This used to happen when SetPref was
    called, now a script must request it explicitly.
  <DT>
    GetPref(str)
  <DD>
    Gets the value of the preference item whose name is contained in str. Only
    boolean, integer, real, string and file preference items may be returned.
    Boolean and real items are returned with integer type and file items are
    returned with string type. Encodings (NewCharset) are returned as magic numbers,
    these are meaningless outside the context of get/set Pref.
  <DT>
    <A NAME="SetPrefs">SetPrefs</A>(str,val[,val2])
  <DD>
    Sets the value of the preference item whose name is contained in str. If
    the preference item has a real type then a second argument may be passed
    and the value set will be val/val2. The NewCharset preference item may be
    set to a magic number as provided by GetPref, or by one of the encoding strings
    accepted by Reencode()
  <DT>
    GetEnv(str)
  <DD>
    Returns the value of the unix environment variable named by str.
  <DT>
    UnicodeFromName(name)
  <DD>
    Looks the string "name" up in FontForge's database of commonly used glyph
    names and returns the unicode value associated with that name, or -1 if not
    found. This does <EM>not</EM> check the current font (if any).
  <DT>
    Chr(int)<BR>
    Chr(array)
  <DD>
    Takes an integer [0,255] and returns a single character string containing
    that code point. Internally FontForge interprets strings as if they were
    in ISO8859-1 (well really, FontForge just uses ASCII-US internally). If passed
    an array, it should be an array of integers and the result is the string.
  <DT>
    Ord(string[,pos])
  <DD>
    Returns an array of integers representing the encoding of the characters
    in the string. If pos is given it should be an integer less than the string
    length and the function will return the integer encoding of that character
    in the string.
  <DT>
    Utf8(int)
  <DD>
    Takes an integer [0,0x10ffff] and returns the utf8 string representing that
    unicode code point. If passed an array of integers it will generate a utf8
    string containing all of those unicode code points. (it does not expect to
    get surrogates).
  <DT>
      <HR>
  <DT>
    FontsInFile(filename)
  <DD>
    Returns an array of strings containing the names of all fonts within a file.
    Most files contain one font, but some (mac font suitcases, dfonts, ttc files,
    svg files, etc) may contain several. If the file contains no fonts (or the
    file doesn't exist, or the fonts aren't named), a zero length array is returned.
    It does not open the font. It can execute without a current font.
  <DT>
    Open(filename[,flags])
  <DD>
    This makes the font named by filename be the current font. If filename has
    not yet been loaded into memory it will be loaded now. It can execute without
    a current font.<BR>
    When loading from a ttc file (mac suitcase, dfont, svg, etc), a particular
    font may be selected by placing the fontname in parens and appending it to
    the filename, as <CODE>Open("gulim.ttc(Dotum)")</CODE><BR>
    The optional flags argument current has only one flag in it:
    <UL>
      <LI>
	1 =&gt; the user does have the appropriate license to examine the font no
	matter what the fstype setting is.
    </UL>
  <DT>
    New()
  <DD>
    This creates a new font. It can execute with no current font.
  <DT>
    Close()
  <DD>
    This frees up any memory taken up by the current font and drops it off the
    list of loaded fonts. After this executes there will be no current font.
  <DT>
    Save([filename])
  <DD>
    If no filename is specified then this saves the current font back into its
    sfd file (if the font has no sfd file then this is an error). With one argument
    it executes a SaveAs command, saving the current font to that filename.
  <DT>
    Generate(filename[,bitmaptype[,fmflags[,res[,mult-sfd-file]]]])
  <DD>
    Generates a font. The type of font is determined by the extension of the
    filename. Valid extensions are:
    <UL>
      <LI>
	pfa
      <LI>
	pfb
      <LI>
	bin (a mac postscript (pfb) resource in a mac binary wrapper)<BR>
	res (on the Mac itself FontForge will put the result directly into a font
	suitcase file, and the extension should be ".res" rather than ".bin")
	<P>
	Note: you must also create a bitmap font in NFNT format or the mac will not
	recognize your postscript font.
      <LI>
	%s.pfb/%s.pfa (splits a big font up into multiple pfb fonts each with 256
	characters)
      <LI>
	mm.pfa (multiple master font in ascii format)
      <LI>
	mm.pfb (multiple master font in binary format)
      <LI>
	pt3 (type 3)
      <LI>
	ps (type 0)
      <LI>
	t42 (type 42, truetype wrapped in PostScript)
      <LI>
	cid.t42 (type 42 cid font)
      <LI>
	cid (non-otf cid font)
      <LI>
	cff (bare cff font)
      <LI>
	cid.cff (bare cff cid-keyed font)
      <LI>
	ttf
      <LI>
	sym.ttf (a truetype file with a symbol (custom) encoding)
      <LI>
	ttf.bin (a mac truetype resource in a mac binary wrapper)<BR>
	suit (on the Mac itself FontForge will put the result directly into a font
	suitcase file, and the extension should be ".suit" not ".ttf.bin")
      <LI>
	dfont (a mac truetype resource in a dfont file)
      <LI>
	otf (either cid or not depending on the font)
      <LI>
	otf.dfont (a mac opentype resource in a dfont file)
      <LI>
	svg (an svg font)
      <LI>
	&lt;null extension&gt; If you don't want to generate an outline font at all
	(but do want to provide a filename for bitmap or metrics files) then provide
	a null extension (ie. <CODE>"Times."</CODE> but NOT <CODE>"Times"</CODE>).
    </UL>
    <P>
    If present, bitmaptype may be one of:
    <UL>
      <LI>
	bdf
      <LI>
	ttf (for EBDT/bdat table in truetype/opentype)
      <LI>
	sbit (for EBDT/bdat table in truetype without any outline font)
      <LI>
	bin (for nfnt in macbinary)
	<P>
	NOTE: Mac OS/X does not appear to support NFNT bitmaps. However even though
	unused itself, an NFNT bitmap must be present for a resource based postscript
	font to be used.
      <LI>
	fnt (For windows FNT format)
      <LI>
	otb (For X11 opentype bitmap format)
      <LI>
	"" for no bitmaps
    </UL>
    <P>
    If you do not wish to generate an outline font then give the filename the
    extension of ".bdf".<BR>
    fmflags controls
    <UL>
      <LI>
	-1 =&gt; default (generate an afm file for postscript fonts, never generate
	a pfm file, full 'post' table, ttf hints)
      <LI>
	fmflags&amp;1 =&gt; generate an afm file (if you are generating a multiple
	master font then setting this flag means you get several afm files (one for
	each master design, and one for the default version of the font) and an amfm
	file)
      <LI>
	fmflags&amp;2 =&gt; generate a pfm file
      <LI>
	fmflags&amp;4 =&gt; generate a short 'post' table with no glyph name info
	in it.
      <LI>
	fmflags&amp;8 =&gt; do not include ttf instructions
      <LI>
	fmflags&amp;0x10 =&gt; where apple and ms/adobe differ about the format of
	a true/open type file, use apple's definition (otherwise use ms/adobe)<BR>
	Currently this affects bitmaps stored in the font (Apple calls the table
	'bdat', ms/adobe 'EBDT'), the PostScript name in the 'name' table (Apple
	says it must occur exactly once, ms/adobe say at least twice), and whether
	morx/feat/kern/opbd/prop/lcar or GSUB/GPOS/GDEF tables are generated.
      <LI>
	fmflags&amp;0x20 =&gt; generate a '<A HREF="non-standard.html#PfEd">PfEd</A>'
	table and store glyph comments
      <LI>
	fmflags&amp;0x40 =&gt; generate a '<A HREF="non-standard.html#PfEd">PfEd</A>'
	table and store glyph colors
      <LI>
	fmflags&amp;0x80 =&gt; generate tables so the font will work on both Apple
	and MS platforms.
      <LI>
	fmflags&amp;0x100 =&gt; generate a glyph map file (GID=&gt;glyph name, unicode
	map)
      <LI>
	fmflags&amp;0x10000 =&gt; generate a tfm file
      <LI>
	fmflags&amp;0x40000 =&gt; do not do flex hints
      <LI>
	fmflags&amp;0x80000 =&gt; do not include postscript hints
      <LI>
	fmflags&amp;0x200000 =&gt; round postscript coordinates
    </UL>
    <P>
    res controls the resolution of generated bdf fonts. A value of -1 means fontforge
    will guess for each strike.
    <P>
    If the filename has a ".mult" extension then a "mult-sfd-file" may be present.
    This is the filename of a file containing the mapping from the current encoding
    into the subfonts. <A HREF="Big5.txt">Here is an example</A>. If this file
    is not present FontForge will go through its default search process to find
    a file for the encoding, and if it fails the fonts will not be saved.
  <DT>
    GenerateFamily(filename,bitmaptype,fmflags,array-of-font-filenames)
  <DD>
    Generates a mac font family (FOND) from the fonts (which must be loaded)
    in the array-of-font-filenames. filename, bitmaptype, fmflags are as above.
    <BLOCKQUOTE>
      <PRE>#!/usr/local/bin/fontforge
a = Array($argc-1)
i = 1
j = 0
while ( i &lt; $argc )
# Open each of the fonts
  Open($argv[i], 1)
# and store the filenames of all the styles in the array
  a[j] = $filename
  j++
  i++
endloop

GenerateFamily("All.otf.dfont","dfont",16,a)
</PRE>
    </BLOCKQUOTE>
  <DT>
    ControlAfmLigatureOutput(script,lang,ligature-tag-list)
  <DD>
    All three arguments must be strings. The first two must be strings containing
    four or fewer characters, the third a string containing a comma separated
    list of 4 (or fewer) character strings. Ligatures will be placed in an AFM
    file only if
    <UL>
      <LI>
	their tags match one of the entries in the list
      <LI>
	they are active in the given script with the given language ("*" acts as
	a wildcard for both script and language).
    </UL>
    <P>
    The default setting is:
    <BLOCKQUOTE>
      <PRE>ControlAfmLigatureOutput("*","dflt","liga,rlig")
</PRE>
    </BLOCKQUOTE>
  <DT>
    Import(filename[,toback[,flags]])
  <DD>
    Either imports a bitmap font into the database, or imports background image[s]
    into various glyphs. There may be one or two arguments. The first must be
    a string representing a filename. The extension of the file determines how
    the import proceeds.
    <UL>
      <LI>
	If the extension is ".bdf" then a bdf font will be imported
      <LI>
	If the extension is ".pcf" then a pcf font will be imported.
      <LI>
	If the extension is ".ttf" then the EBDT or bdat table of the ttf file will
	be searched for bitmap fonts
      <LI>
	If the extension is "pk" then a metafont pk (bitmap font) file will be import
	and by default placed in the background
      <LI>
	Otherwise if the extension is an image extension, and any loaded images will
	be placed in the background.
	<UL>
	  <LI>
	    If the filename contains a "*" then it should be a recognized template in
	    which case all images which match that template will be loaded appropriately
	    and stored in the background
	  <LI>
	    Otherwise there may be several filenames (separated by semicolons), the first
	    will be placed in the background of the first selected glyph, the second
	    into the background of the second selected glyph, ...
	</UL>
      <LI>
	If the extension is "eps" then an encapsulated postscript file will be merged
	into the foreground. The file may be specified as for images (except the
	extension should be "eps" rather than an image extension). FontForge is limited
	in its ability to read eps files.
      <LI>
	If the extension is "svg" then an svg file will be read into the foreground.
    </UL>
    <P>
    If present the second argument must be an integer, if the first argument
    is a bitmap font then the second argument controls whether it is imported
    into the bitmap list (0) or to fill up the backgrounds of glyphs (1). For
    eps and svg files this argument controls whether the splines are added to
    the foreground or the background layer of the glyph.
    <P>
    If there is a third argument it must also be an integer and provides a set
    of flags controling the behavior of importing an EPS file.
    <UL>
      <LI>
	8 =&gt; correct direction
      <LI>
	4 =&gt; attempt to handle TeX erasers (stroking with a white pen)
      <LI>
	2 =&gt; remove overlap
    </UL>
  <DT>
    Export(format[,bitmap-size])
  <DD>
    For each selected glyph in the current font, this command will export that
    glyph into a file in the current directory. Format must be a string and must
    be one of
    <UL>
      <LI>
	eps -- the selected glyphs will have their splines output into eps files.
	The files will be named "&lt;glyph-name&gt;_&lt;font-name&gt;.eps".
      <LI>
	pdf -- the selected glyphs will have their splines output into pdf files.
	The files will be named "&lt;glyph-name&gt;_&lt;font-name&gt;.pdf".
      <LI>
	svg -- the selected glyphs will have their splines output into svg files.
	The files will be named "&lt;glyph-name&gt;_&lt;font-name&gt;.svg".
      <LI>
	fig -- the selected glyphs will have their splines converted (badly) into
	xfig files. The files will be named
	"&lt;glyph-name&gt;_&lt;font-name&gt;.fig".
      <LI>
	xbm -- The second argument specifies a bitmap font size, the selected glyphs
	in that bitmap font will be output as xbm files. The files will be named
	"&lt;glyph-name&gt;_&lt;font-name&gt;.xbm".
      <LI>
	bmp -- The second argument specifies a bitmap font size, the selected glyphs
	in that bitmap font will be output as bmp files. The files will be named
	"&lt;glyph-name&gt;_&lt;font-name&gt;.bmp".
      <LI>
	png -- The second argument specifies a bitmap font size, the selected glyphs
	in that bitmap font will be output as png files. The files will be named
	"&lt;glyph-name&gt;_&lt;font-name&gt;.png".
    </UL>
  <DT>
    MergeKern(filename)
  <DD>
    Loads Kerning info out of either an afm or a tfm file and merges it into
    the current font.
  <DT>
    <A NAME="PrintSetup">PrintSetup</A>(type,[printer[,width,height]])
  <DD>
    Allows you to configure the print command. Type may be a value between 0
    and 4
    <UL>
      <LI>
	0 =&gt; print with lp
      <LI>
	1 =&gt; print with lpr
      <LI>
	2 =&gt; output to ghostview
      <LI>
	3 =&gt; output to PostScript file
      <LI>
	4 =&gt; other printing command
      <LI>
	5 =&gt; output to a pdf file
    </UL>
    <P>
    If the type is 4 (other) and the second argument is specified, then the second
    argument should be a string containing the "other" printing command.<BR>
    If the type is 0 (lp) or 1 (lpr) and the second argument is specified, then
    the second argument should contain the name of a laser printer<BR>
    (If the second argument is a null string neither will be set).
    <P>
    The third and fourth arguments should specify the page width and height
    respectively. Units are in 1/72 inches (almost points), so 8.5x11" paper
    is 612,792 and A4 paper is (about) 595,842.
  <DT>
    PrintFont(type[,pointsize[,sample-text-file[,output-file]]])
  <DD>
    Prints the current font according to the
    <A HREF="scripting.html#PrintSetup">PrintSetup</A>. The values for type are
    (meanings are described in the <A HREF="print.html">section on printing</A>):
    <UL>
      <LI>
	0 =&gt; Prints a full font display at the given pointsize
      <LI>
	1 =&gt; Prints selected glyphs to fill page
      <LI>
	2 =&gt; Prints selected glyphs at multiple pointsizes
      <LI>
	3 =&gt; Prints a text sample at the given pointsize(s)
    </UL>
    <P>
    The pointsize is either a single integer or an array of integers. It is only
    meaningful for types 0 and 3. If omitted or set to 0 a default value will
    be chosen. The font display will only look at one value.
    <P>
    If you selected print type 3 then you may provide the name of a file containing
    sample text. This file may either be in ucs2 format (preceded by a 0xfeff
    value), or in the current default encoding. A null string or an omitted argument
    will cause FontForge to use a default value.
    <P>
    If your PrintSetup specified printing to a file (either PostScript or pdf)
    then the fourth argument provides the filename of the output file.
  <DT>
    <A NAME="Quit">Quit</A>(status)
  <DD>
    Causes FontForge to exit with the given status. It can execute with no current
    font. 
      <HR>
  <DT>
    Cut
  <DD>
    Makes a copy of all selected glyphs and saves it in the clipboard, then clears
    out the selected glyphs
  <DT>
    Copy
  <DD>
    Makes a copy of all selected glyphs.
  <DT>
    CopyReference
  <DD>
    Makes references to all selected glyphs and stores them in the clipboard.
  <DT>
    CopyWidth
  <DD>
    Stores the widths of all selected glyphs in the clipboard
  <DT>
    CopyVWidth
  <DD>
    Stores the vertical widths of all selected glyphs in the clipboard
  <DT>
    CopyLBearing
  <DD>
    Stores the left side bearing of all selected glyphs in the clipboard
  <DT>
    CopyRBearing
  <DD>
    Stores the right side bearing of all selected glyphs in the clipboard
  <DT>
    CopyGlyphFeatures(arg,...)
  <DD>
    This copies features from the currently selected glyph (only one) and stores
    them in the clipboard.
    <P>
    arg may be either a string in which case it should be either a four character
    opentype tag (like "kern") or a mac feature setting (like "&lt;1,1&gt;").
    Or it may be an integer in which case it must be the integer representation
    of one of the above. Or arg may be an array of strings and integers (in this
    case there may be only one argument).
    <P>
    The feature 'kern' will match any kerning pair that has the currently selected
    glyph as the first character of the two. The (made up) feature '_krn' will
    match any kerning pair that has the currently selected glyph as the last
    character of the two. Similary for 'vkrn' and '_vkn'.
  <DT>
    Paste
  <DD>
    Copies the clipboard into the selected glyphs of the current font (removing
    what was there before)
  <DT>
    PasteInto
  <DD>
    Copies the clipboard into the current font (merging with what was there before)
  <DT>
    PasteWithOffset(xoff,yoff)
  <DD>
    Translates the clipboard by xoff,yoff before doing a PasteInto(). Can be
    used to build accented glyphs.
  <DT>
    SameGlyphAs
  <DD>
    If the clipboard contains a reference to a single glyph then this makes all
    selected glyphs refer to that one.
  <DT>
    Clear
  <DD>
    Clears out all selected glyphs
  <DT>
    ClearBackground
  <DD>
    Clears the background of all selected glyphs
  <DT>
    CopyFgToBd
  <DD>
    Copies all foreground splines into the background in all selected glyphs
  <DT>
    Join([fudge])
  <DD>
    Joins open paths in selected glyphs. If fudge is specified then the endpoints
    only need to be within fudge em-units of each other to be merged.
  <DT>
    UnlinkReference
  <DD>
    Unlinks all references within all selected glyphs
  <DT>
    SelectAll
  <DD>
    Selects all glyphs
  <DT>
    SelectNone
  <DD>
    Deselects all glyphs
  <DT>
    Select(arg1, arg2, ...)
  <DD>
    This clears out the current selection, then for each pair of arguments it
    selects all glyphs between (inclusive) the bounds specified by the pair.
    If there is a final singleton argument then that single glyph will be selected.
    An argument may be specified by:
    <UL>
      <LI>
	an integer which specifies the location in the current font's encoding
      <LI>
	a postscript unicode name which gets mapped into the current font's encoding
      <LI>
	a unicode code point (0u61) which gets mapped to the current font's encoding
      <LI>
	If Select is given exactly one argument and that argument is an array then
	the selection will be set to that specified in the array. So array[0] would
	set the selection of the glyph at encoding 0 and so forth. The array may
	have a different number of elements from that number of glyphs in the font.
    </UL>
  <DT>
    SelectMore(arg1, arg2, ...)
  <DD>
    The same as the previous command except that it does not clear the selection,
    so it extends the current selection.
  <DT>
    SelectIf(arg1,arg2, ...)
  <DD>
    The same as Select() except that instead of signalling an error when a glyph
    is not in the font it returns an error code.
    <UL>
      <LI>
	0 =&gt; there were no errors but no glyphs were selected
      <LI>
	&lt;a positive number&gt; =&gt; there were no errors and this many glyphs
	were selected
      <LI>
	-2 =&gt; there was an error and no glyphs were selected
      <LI>
	-1 =&gt; there was an error and at least one glyph was selected before that.
    </UL>
  <DT>
    SelectByATT(type,tags,contents,search-type)
  <DD>
    See the <A HREF="selectbyatt.html">Select By ATT menu command</A>. The values
    for type are:
    <TABLE>
      <TR>
	<TD><CODE>"Position"</CODE></TD>
	<TD>Simple position</TD>
      </TR>
      <TR>
	<TD><CODE>"Pair"</CODE></TD>
	<TD>Pairwise positioning (but not kerning)</TD>
      </TR>
      <TR>
	<TD><CODE>"Substitution"</CODE></TD>
	<TD>Simple substitution</TD>
      </TR>
      <TR>
	<TD><CODE>"AltSubs"</CODE></TD>
	<TD>Alternate substitution</TD>
      </TR>
      <TR>
	<TD><CODE>"MultSubs"</CODE></TD>
	<TD>Multiple substitution</TD>
      </TR>
      <TR>
	<TD><CODE>"Ligature"</CODE></TD>
	<TD>Ligature</TD>
      </TR>
      <TR>
	<TD><CODE>"LCaret"</CODE></TD>
	<TD>Ligature caret</TD>
      </TR>
      <TR>
	<TD><CODE>"Kern"</CODE></TD>
	<TD>Kerning</TD>
      </TR>
      <TR>
	<TD><CODE>"VKern"</CODE></TD>
	<TD>Vertical Kerning</TD>
      </TR>
      <TR>
	<TD><CODE>"Anchor"</CODE></TD>
	<TD>Anchor class</TD>
      </TR>
    </TABLE>
    <P>
    And for search_type
    <OL>
      <LI>
	Select Results
      <LI>
	Merge Selection
      <LI>
	Restrict Selection
    </OL>
  <DT>
      <HR>
  <DT>
    Reencode(encoding-name[,force])
  <DD>
    Reencodes the current font into the given encoding which may be:<BR>
    compacted,original,<BR>
    iso8859-1, isolatin1, latin1, iso8859-2, latin2, iso8859-3, latin3, iso8859-4,
    latin4, iso8859-5, iso8859-6, iso8859-7, iso8859-8, iso8859-9, iso8859-10,
    isothai, iso8859-13, iso8859-14, iso8859-15, latin0, koi8-r, jis201, jisx0201,
    AdobeStandardEncoding, win, mac, symbol, wansung, big5, johab, jis208, jisx0208,
    jis212, jisx0212, sjis, gh2312, gb2312packed, unicode, iso10646-1,
    TeX-Base-Encoding, one of the user defined encodings, or something of the
    form "unicode-plane-%x" to represent the x'th iso10646 plane (where the BMP
    is plane 0).<BR>
    You may also specify that you want to force the encoding to be the given
    one.
  <DT>
    SetCharCnt(cnt)
  <DD>
    Sets the number of glyphs in the font.
  <DT>
    LoadEncodingFile(filename)
  <DD>
  <DT>
    SetFontOrder(order)
  <DD>
    Sets the font's order. Order must be either 2 (quadratic) or 3 (cubic). It
    returns the old order.
  <DT>
    SetFontHasVerticalMetrics(flag)
  <DD>
    Sets whether the font has vertical metrics or not. A 0 value means it does
    not, any other value means it does. Returns the old setting.
  <DT>
    SetFontNames(fontname[,family[,fullname[,weight[,copyright-notice[,fontversion]]]]])
  <DD>
    Sets various postscript names associated with a font. If a name is omitted
    (or is the empty string) it will not be changed.
  <DT>
    SetFondName(fondname)
  <DD>
    Sets the FOND name of the font.
  <DT>
    SetItalicAngle(angle[,denom])
  <DD>
    Sets the postscript italic angle field appropriately. If denom is specified
    then angle will be divided by denom before setting the italic angle field
    (a hack to get real values). The angle should be in degrees.
  <DT>
    SetMacStyle(val)<BR>
    SetMacStyle(str)
  <DD>
    The argument may be either an integer or a string. If an integer it is a
    set of bits expressing styles as defined on the mac
    <TABLE CELLPADDING="2">
      <TR>
	<TD>0x01</TD>
	<TD>Bold</TD>
      </TR>
      <TR>
	<TD>0x02</TD>
	<TD>Italic</TD>
      </TR>
      <TR>
	<TD>0x04</TD>
	<TD>Underline</TD>
      </TR>
      <TR>
	<TD>0x08</TD>
	<TD>Outline</TD>
      </TR>
      <TR>
	<TD>0x10</TD>
	<TD>Shadow</TD>
      </TR>
      <TR>
	<TD>0x20</TD>
	<TD>Condensed</TD>
      </TR>
      <TR>
	<TD>0x40</TD>
	<TD>Extended</TD>
      </TR>
      <TR>
	<TD>-1</TD>
	<TD>FontForge should guess the styles from the fontname</TD>
      </TR>
    </TABLE>
    <P>
    The bits 0x20 and 0x40 (condensed and extended) may not both be set.
    <P>
    If the argument is a string then the string should be the concatenation of
    various style names, as "Bold Italic Condensed"
  <DT>
    SetTTFName(lang,nameid,utf8-string)<B></B>
  <DD>
    Sets the indicated truetype name in the MS platform. Lang must be one of
    the
    <A HREF="http://partners.adobe.com/asn/tech/type/opentype/name.jsp#lang3">language/locales</A>
    supported by MS, and nameid must be one of the
    <A HREF="http://partners.adobe.com/asn/tech/type/opentype/name.jsp#enc4">small
    integers used to indicate a standard name</A>, while the final argument should
    be a utf8 encoded string which will become the value of that entry. A null
    string ("") may be used to clear an entry.<BR>
    Example: To set the SubFamily string in the American English
    language/locale<BR>
    <CODE>&nbsp; &nbsp;SetTTFName(0x409,2,"Bold Oblique")</CODE>
  <DT>
    GetTTFName(lang,nameid)
  <DD>
    The lang and nameid arguments are as above. This returns the current value
    as a utf8 encoded string. Combinations which are not present will be returned
    as "".
  <DT>
    SetPanose(array)<BR>
    SetPanose(index,value)
  <DD>
    This sets the panose values for the font. Either it takes an array of 10
    integers and sets all the values, or it takes two integer arguments and sets
    <CODE>font.panose[index] = value</CODE>
  <DT>
    SetUniqueID(value)
  <DD>
    Sets the postscript uniqueid field as requested. If you give a value of 0
    then FontForge will pick a reasonable random number for you.
  <DT>
    SetTeXParams(type,design-size,slant,space,stretch,shrink,xheight,quad,extraspace[...])
  <DD>
    Sets the TeX (text) font parameters for the font.<BR>
    Type may be 1, 2 or 3, depending on whether the font is text, math or math
    extension. <BR>
    DesignSize is the pointsize the font was designed for.<BR>
    The remaining parameters are described in Knuth's The MetaFont Book, pp.
    98-100.<BR>
    Slant is expressed as a percentage. All the others are expressed in
    em-units.<BR>
    If type is 1 then the 9 indicated arguments are required. If type is 2 then
    24 arguments are required (the remaining 15 are described in the metafont
    book). If type is 3 then 15 arguments are required.
  <DT>
    SetCharName(name[,set-from-name-flag])
  <DD>
    Sets the currently selected glyph to have the given name. If set-from-name-flag
    is absent or is present and true then it will also set the unicode value
    and the ligature string to match the name.
  <DT>
    SetUnicodeValue(uni[,set-from-value-flag])
  <DD>
    Sets the currently selected glyph to have the given unicode value. If
    set-from-value-flag is absent or is present and true then it will also set
    the name and the ligature string to match the value.
  <DT>
    SetCharColor(color)
  <DD>
    Sets any currently selected glyphs to have the given color (expressed as
    24 bit rgb (0xff0000 is red) with the special value of -2 meaning the default
    color.
  <DT>
    SetCharComment(comment)
  <DD>
    Sets the currently selected glyph to have the given comment. The comment
    is converted via the current encoding to unicode.
  <DT>
    BitmapsAvail(sizes)
  <DD>
    Controls what bitmap sizes are stored in the font's database. It is passed
    an array of sizes. If a size is specified which is not in the font database
    it will be generated. If a size is not specified which is in the font database
    it will be removed. A size which is specified and present in the font database
    will not be touched.<BR>
    If you want to specify greymap fonts then the low-order 16 bits will be the
    pixel size and the high order 16 bits will specify the bits/pixel. Thus 0x8000c
    would be a 12 pixel font with 8 bits per pixel, while either 0xc or 0x1000c
    could be used to refer to a 12 pixel bitmap font.
  <DT>
    BitmapsRegen(sizes)
  <DD>
    Allows you to update specific bitmaps in an already generated bitmap font.
    It will regenerate the bitmaps of all selected glyphs at the specified
    pixelsizes.
  <DT>
    ApplySubstitution(script,lang,tag)
  <DD>
    All three arguments must be strings of no more that four characters (shorter
    strings will be padded with blanks to become 4 character strings). For each
    selected glyph this command will look up that glyph's list of substitutions,
    and if it finds a substitution with the tag "tag" (and if that substitution
    matches the script and language combination) then it will apply the
    substitution-- that is it will find the variant glyph specified in the
    substitution and replace the current glyph with the variant, and remove the
    variant from the font.
    <P>
    FontForge recognizes the string "*" as a wildcard for both the script and
    the language (not for the tag though). So you wish to replace all glyphs
    with their vertical variants:
    <BLOCKQUOTE>
      <PRE>SelectAll()
ApplySubstitution("*","*","vrt2")
</PRE>
    </BLOCKQUOTE>
  <DT>
    Transform(t1,t2,t3,t4,t5,t6)
  <DD>
    Each argument will be divided by 100. and then all selected glyphs will be
    transformed by this matrix
  <DT>
    HFlip([about-x])
  <DD>
    All selected glyphs will be horizontally flipped about the vertical line
    through x=about-x. If no argument is given then all selected glyphs will
    be flipped about their central point.
  <DT>
    VFlip([about-y])
  <DD>
    All selected glyphs will be vertically flipped about the horizontal line
    through y=about-y. If no argument is given then all selected glyphs will
    be flipped about their central point.
  <DT>
    Rotate(angle[,ox,oy])
  <DD>
    Rotates all selected glyph the specified number of degrees. If the last two
    args are specified they provide the origin of the rotation, otherwise the
    center of the glyph is used.
  <DT>
    Scale(factor[,yfactor][,ox,oy])
  <DD>
    All selected glyphs will be scaled (scale factors are in percent)
    <UL>
      <LI>
	with one argument they will be scaled uniformly about the glyph's center
	point
      <LI>
	with two arguments the first specifies the scale factor for x, the second
	for y. Again scaling will be about the center point
      <LI>
	with three arguments they will be scaled uniformly about the specified center
      <LI>
	with four arguments they will be scaled differently about the specified center
    </UL>
  <DT>
    Skew(angle[,ox,oy])<BR>
    Skew(angle-num,angle-denom[,ox,oy])
  <DD>
    All selected glyphs will be skewed by the given angle.
  <DT>
    Move(delta-x,delta-y)
  <DD>
    All selected glyphs will have their points moved the given amount.
  <DT>
    ScaleToEm(em-size)<BR>
    ScaleToEm(ascent,descent)
  <DD>
    Change the font's ascent and descent and scale everything in the font to
    be in the same proportion to the new em (which is the sum of ascent and descent)
    value that it was to the old value.
  <DT>
    <A NAME="NonLinear">NonLinearTransform</A>(x-expression,y-expression)
  <DD>
    Takes two string arguments which must contain valid expressions of x and
    y and transforms all selected glyphs using those expressions.
    <BLOCKQUOTE>
      <PRE>&lt;e0&gt; := "x" | "y" | "-" &lt;e0&gt; | "!" &lt;e0&gt; | "(" &lt;expr&gt; ")" |
	"sin" "(" &lt;expr&gt; ")" | "cos" "(" &lt;expr&gt; ")" | "tan" "(" &lt;expr&gt; ")" | 
	"log" "(" &lt;expr&gt; ")" | "exp" "(" &lt;expr&gt; ")" | "sqrt" "(" &lt;expr&gt; ")" |
	"abs" "(" &lt;expr&gt; ")" | 
	"rint" "(" &lt;expr&gt; ")" | "float" "(" &lt;expr&gt; ")" | "ceil" "(" &lt;expr&gt; ")"
&lt;e1&gt; := &lt;e0&gt; "^" &lt;e1&gt;
&lt;e2&gt; := &lt;e1&gt; "*" &lt;e2&gt; | &lt;e1&gt; "/" &lt;e2&gt; | &lt;e1&gt; "%" &lt;e2&gt; 
&lt;e3&gt; := &lt;e2&gt; "+" &lt;e3&gt; | &lt;e2&gt; "-" &lt;e3&gt;
&lt;e4&gt; := &lt;e3&gt; "==" &lt;e4&gt; | &lt;e3&gt; "!=" &lt;e4&gt; |
	&lt;e3&gt; "&gt;=" &lt;e4&gt; | &lt;e3&gt; "&gt;" &lt;e4&gt; |
	&lt;e3&gt; "&lt;=" &lt;e4&gt; | &lt;e3&gt; "&lt;" &lt;e4&gt; 
&lt;e5&gt; := &lt;e4&gt; "&amp;&amp;" &lt;e5&gt; | &lt;e4&gt; "||" &lt;e5&gt;
&lt;expr&gt; := &lt;e5&gt; "?" &lt;expr&gt; ":"

</PRE>
    </BLOCKQUOTE>
    <P>
    Example: To do a perspective transformation with a vanishing point at (200,300):
    <BLOCKQUOTE>
      <PRE>NonLinearTrans("200+(x-200)*abs(y-300)/300","y")
</PRE>
    </BLOCKQUOTE>
    <P>
    This command is not available in the default build, you must modify the file
    <CODE>configure-fontforge.h</CODE> and then rebuild FontForge.
  <DT>
    ExpandStroke(width)<BR>
    ExpandStroke(width,line cap, line join)<BR>
    ExpandStroke(width,line cap, line join,0,removeinternal /external flag)<BR>
    ExpandStroke(width,calligraphic-angle,height-numerator,height-denom)<BR>
    ExpandStroke(width,calligraphic-angle,height-numerator,height-denom, 0, remove
    internal/external flag)
  <DD>
    In the first format a line cap of "butt" and line join of "round" are
    implied.<BR>
    A value of 1 for remove internal/external will remove the internal contour,
    a value of 2 will remove the external contour.<BR>
    The first three calls simulate the PostScript "stroke" command, the two final
    simulate a caligraphic pen.
    <DL>
      <DT>
	Width
      <DD>
	In the PostScript "stoke" command the width is the distance between the two
	generated curves. To be more precise, at ever point on the original curve,
	a point will be added to each of the new curves at width/2 units as measured
	on a vector normal to the direction of the original curve at that point.<BR>
	In a caligraphic pen, the width is the width of the pen used to draw the
	curve.
      <DT>
	Line-cap
      <DD>
	Can have one of three values: 0=&gt; butt, 1=&gt;round, 2=&gt;square
      <DT>
	Line-join
      <DD>
	Can have one of three values: 0=&gt;miter, 1=&gt;round, 2=&gt;bevel
      <DT>
	caligraphic-angle
      <DD>
	the (fixed) angle at which the pen is held.
      <DT>
	height-numerator/denominator
      <DD>
	These two values specify a ratio between the height and the width<BR>
	height = numerator * width / denominator<BR>
	(the scripting language only deals in integers, so when fractions are needed
	this kludge is used)
      <DT>
	remove internal/external contour flags
      <DD>
	1 =&gt; remove internal contour<BR>
	2=&gt; remove external contour<BR>
	(you may not remove both contours)<BR>
	4 =&gt; run remove overlap on result (buggy)
    </DL>
  <DT>
    Outline(width)
  <DD>
    Strokes all selected glyphs with a stroke of the specified width (internal
    to the glyphs). The bounding box of the glyph will not change. In other words
    it produces what the mac calls the "Outline Style".
  <DT>
    Inline(width,gap)
  <DD>
    Produces an outline as above, and then shrinks the glyph so that it fits
    inside the outline. In other words, it produces an inlined glyph.
  <DT>
    Shadow(angle,outline-width,shadow-width)
  <DD>
    Converts the selected glyphs into shadowed versions of themselves.
  <DT>
    Wireframe(angle,outline-width,shadow-width)
  <DD>
    Converts the selected glyphs into wireframed versions of themselves.
  <DT>
    RemoveOverlap()
  <DD>
    Does the obvious.
  <DT>
    OverlapIntersect()
  <DD>
    Removes everything but the intersection.
  <DT>
    FindIntersections()
  <DD>
    Finds everywhere that splines cross and creates points there.
  <DT>
    Simplify()<BR>
    Simplify(flags,error[,tan_bounds[,bump_size[,error_denom]]])
  <DD>
    With no arguments it does the obvious. If flags is -1 it does a Cleanup,
    otherwise flags should be a bitwise or of
    <UL>
      <LI>
	1 -- Slopes may change at the end points.
      <LI>
	2 -- Points which are extremum may be removed
      <LI>
	4 -- Corner points may be smoothed into curves
      <LI>
	8 -- Smoothed points should be snapped to a horizontal or vertical tangent
	if they are close
      <LI>
	16 -- Remove bumps from lines
    </UL>
    <P>
    The error argument is the number of pixels by which the modified path is
    allowed to stray from the true path.<BR>
    The tan_bounds argument specifies the tangent of the angle between the curves
    at which smoothing will stop (argument is multiplied by .01 before use).<BR>
    And bump_size gives the maximum distance a bump can move from the line and
    still be smoothed out.<BR>
    If a fifth argument is given then it will be treated as the denominator of
    the error term (so users can express fraction pixel distances).
  <DT>
    NearlyHvCps([error[,err-denom]])
  <DD>
    Checks for control points which are almost, but not quite horzontal or vertical
    (where almost means (say) that <CODE>abs( (control point).x - point.x ) &lt;
    error</CODE>, where error is either:
    <TABLE CELLPADDING="2">
      <TR>
	<TD>.1</TD>
	<TD>if no arguments are given</TD>
      </TR>
      <TR>
	<TD>first-arg</TD>
	<TD>if one argument is given</TD>
      </TR>
      <TR>
	<TD>first-arg/second-arg</TD>
	<TD>if two arguments are given</TD>
      </TR>
    </TABLE>
  <DT>
    NearlyHvLines([error[,err-denom]])
  <DD>
    Checks for lines which are almost, but not quite horzontal or vertical (where
    almost means (say) that <CODE>abs( (end point).x - (start point).x ) &lt;
    error</CODE>, where error is either:
    <TABLE CELLPADDING="2">
      <TR>
	<TD>.1</TD>
	<TD>if no arguments are given</TD>
      </TR>
      <TR>
	<TD>first-arg</TD>
	<TD>if one argument is given</TD>
      </TR>
      <TR>
	<TD>first-arg/second-arg</TD>
	<TD>if two arguments are given</TD>
      </TR>
    </TABLE>
  <DT>
    AddExtrema()
  <DD>
  <DT>
    RoundToInt([factor])
  <DD>
    Rounds all points/hints/reference-offsets to be integers. If the the "factor"
    argument is specified then it rounds like <CODE>rint(factor * x) /
    factor</CODE>, in other words if you set factor to 100 then it will round
    to hundredths.
  <DT>
    AutoTrace()
  <DD>
  <DT>
    CorrectDirection([unlinkrefs])
  <DD>
    If the an argument is present it must be integral and is treated as a flag
    controlling whether flipped references should be unlinked before the
    CorrectDirection code runs. If the argument is not present, or if it has
    a non-zero value then flipped references will be unlinked.
  <DT>
    DefaultATT(tag)
  <DD>
    For all selected glyphs make a guess as to what might be an appropriate value
    for the given tag. If the tag is "*" then FontForge will apply guesses for
    all features it can.
  <DT>
    AddATT(type,script-lang,tag,flags,variant)<BR>
    AddATT("Position",script-lang,tag,flags,xoff,yoff,h_adv_off,v_adv_off)<BR>
    AddATT("Pair",script-lang,tag,flags,name,xoff,yoff,h_adv_off,v_adv_off,xoff2,yoff2,h_adv_off2,v_adv_off2)
  <DD>
    Allows you to add an Advanced Typography feature to a single selected glyph.
    The first argument may be either: Position, Pair, Substitution, AltSubs,
    MultSubs or Ligature. The second argument should be a script-lang list where
    each 4-character script name is followed by a comma separated list of 4 character
    language names (with the languages enclosed in curly braces). As:<BR>
    <CODE>&nbsp; &nbsp; grek{dflt} latn{dflt,VIT ,ROM }</CODE><BR>
    The third arg should be a 4 character opentype feature tag (or apple
    feature/setting).
    <P>
    The fourth argument should be the <A NAME="otf-flags">otf flags </A>(or -1
    to make FontForge guess appropriate flags).
    <UL>
      <LI>
	0x0001 =&gt; RightToLeft
      <LI>
	0x0002 =&gt; IgnoreBaseGlyphs
      <LI>
	0x0004 =&gt; IgnoreLigatures
      <LI>
	0x0008 =&gt; IgnoreMarks
      <LI>
	0x00F0 =&gt; not defined
      <LI>
	0xFF00 =&gt; not supported
    </UL>
    <P>
    The remaining argument(s) vary depending on the value of the first (type)
    argument. For Position tags there are 4 integral arguments which specify
    how this feature modifies the metrics of this glyph. For Pair type the next
    argument is the name of the other glyph in the pair followed by 8 integral
    arguments, the first 4 specify the changes in positioning to the first glyph,
    the next four the changes for the second char. For substitution tags the
    fifth argument is the name of another glyph which will replace the current
    one. For an AltSubs tag the argument is a space separated list of glyph names
    any of which will replace the current one. For a MultSubs the argument is
    a space separated list of names all of which will replace the current one.
    For a Ligature the argument is a space separated list of glyph names all
    of which will be replaced by the current glyph.
  <DT>
    RemoveATT(type,script-lang,tag)
  <DD>
    Removes any feature tags which match the arguments (which are essentially
    the same as above, except that any of them may be "*" which will match anything).
  <DT>
    CheckForAnchorClass(name)
  <DD>
    Returns 1 if the current font contains an Anchor class with the given name
    (which must be in utf8).
  <DT>
    AddAnchorClass(name,type,script-lang,tag,flags,merge-with)
  <DD>
    These mirror the values of the Anchor class dialog of Element-&gt;Font Info.
    The first argument should be a utf8 encoded name for the anchor class. The
    second should be one of the strings "default", "mk-mk", or "cursive". The
    third should be a script-lang string like:<BR>
    <CODE>&nbsp; &nbsp; grek{dflt} latn{dflt,VIT ,ROM }</CODE><BR>
    The fourth arg should be a 4 character opentype feature tag. The fifth argument
    should be the <A HREF="scripting.html#otf-flags">otf flags </A>(or -1 to
    make FontForge guess appropriate flags). The sixth and last argument should
    be the name of another AnchorClass to be merged into the same lookup (or
    a null string if this class merges with no other class yet).
  <DT>
    RemoveAnchorClass(name)
  <DD>
    Removes the named AnchorClass (and all associated points) from the font.
  <DT>
    AddAnchorPoint(name,type,x,y[,lig-index])
  <DD>
    Adds an AnchorPoint to the currently selected glyph. The first argument is
    the name of the AnchorClass. The second should be one of the strings: "mark",
    "basechar", "baselig", "basemark", "cursentry" or "cursexit". The next two
    values specify the location of the point. The final argument is only present
    for things of type "baselig".
  <DT>
    BuildComposite()
  <DD>
  <DT>
    BuildAccented()
  <DD>
  <DT>
    ReplaceWithReference()
  <DD>
    Finds any glyph which contains an inline copy of one of the selected glyphs,
    and converts that copy into a reference to the appropriate glyph. Selection
    is changed to the set of glyphs which the command alters.
  <DT>
    MergeFonts(other-font-name[,flags])
  <DD>
    Loads other-font-name, and extracts any glyphs from it which are not in the
    current font and moves them to the current font. The flags argument is the
    same as that for Open. Currently the only relevant flag is to say that you
    do have a license to use a font with fstype=2.
  <DT>
    InterpolateFonts(percentage,other-font-name[,flags])
  <DD>
    Interpolates a font which is percentage of the way from the current font
    to the one specified by other-font-name (note: percentage may be negative
    or more than 100, in which case we extrapolate a font). This command changes
    the current font to be the new font.
    <FONT COLOR="Red"><STRONG><SMALL>NOTE:</SMALL></STRONG></FONT> You will need
    to set the fontname of this new font. The flag argument is the same as for
    Open.
  <DT>
      <HR>
  <DT>
    <A NAME="AutoHint">AutoHint</A>()
  <DD>
    <B></B>
  <DT>
    SubstitutionPoints()
  <DD>
  <DT>
    AutoCounter()
  <DD>
  <DT>
    DontAutoHint()
  <DD>
  <DT>
    AutoInstr()
  <DD>
  <DT>
    ClearHints()
  <DD>
  <DT>
    AddHHint(start,width)
  <DD>
    Adds horizontal stem hint to any selected glyphs. The hint starts at location
    "start" and is width wide. A hint will be added to all selected glyphs.
  <DT>
    AddVHint(start,width)
  <DD>
    Adds a vertical stem hint to any selected glyphs. The hint starts at location
    "start" and is width wide. A hint will be added to all selected glyphs.
  <DT>
    ClearCharCounterMasks()
  <DD>
    Clears any counter masks from the (one) selected glyph.
  <DT>
    SetCharCounterMask(cg,hint-index,hint-index,...)
  <DD>
    Creates or sets the counter mask at index cg to contain the hints listed.
    Hint index 0 corresponds to the first hstem hint, index 1 to the second hstem
    hint, etc. vstem hints follow hstems.
  <DT>
    ReplaceCharCounterMasks(array)
  <DD>
    This requires that there be exactly one glyph selected. It will create a
    set of counter masks for that glyph. The single argument must be an array
    of twelve element arrays of integers (in c this would be "int array[][12]").
    This is the format of a type2 counter mask. The number of elements in the
    top level array is the number of counter groups to be specified. The nested
    array thus corresponds to a counter mask, and is treated as an array of bytes.
    Each bit in the byte specifies whether the corresponding hint is active in
    this counter. (there are at most 96 hints, so at most 12 bytes).
    Array[i][0]&amp;0x80 corresponds to the first horizontal stem hint,
    Array[i][0]&amp;0x40 corresponds to the second, Array[i][1]&amp;0x80 corresponds
    to the eighth hint, etc.
  <DT>
    ClearPrivateEntry(key)
  <DD>
    Removes the entry indexed by the given key from the private dictionary of
    the font.
  <DT>
    ChangePrivateEntry(key,val)
  <DD>
    Changes (or adds if the key is not already present) the value in the dictionary
    indexed by key. (all values must be strings even if they represent numbers
    in PostScript)
  <DT>
    GetPrivateEntry(key)
  <DD>
    Returns the entry indexed by key in the private dictionary. All return values
    will be strings. If an entry does not exist a null string is returned.
  <DT>
    SetWidth(width[,relative])
  <DD>
    If the second argument is absent or zero then the width will be set to the
    first argument, if the second argument is 1 then the width will be incremented
    by the first, and if the argument is 2 then the width will be scaled by
    &lt;first argument&gt;/100.0 .
  <DT>
    SetVWidth(vertical-width[,relative])
  <DD>
    If the second argument is absent or zero then the vertical width will be
    set to the first argument, if the second argument is 1 then the vertical
    width will be incremented by the first, and if the argument is 2 then the
    vertical width will be scaled by &lt;first argument&gt;/100.0 .
  <DT>
    SetLBearing(lbearing[,relative])
  <DD>
    If the second argument is absent or zero then the left bearing will be set
    to the first argument, if the second argument is 1 then the left bearing
    will be incremented by the first, and if the argument is 2 then the left
    bearing will be scaled by &lt;first argument&gt;/100.0 .
  <DT>
    SetRBearing(rbearing[,relative])
  <DD>
    If the second argument is absent or zero then the right bearing will be set
    to the first argument, if the second argument is 1 then the right bearing
    will be incremented by the first, and if the argument is 2 then the right
    bearing will be scaled by &lt;first argument&gt;/100.0 .
  <DT>
    CenterInWidth()
  <DD>
  <DT>
    AutoWidth(spacing)
  <DD>
    Guesses at the widths of all selected glyphs so that two adjacent "I" glyphs
    will appear to be spacing em-units apart. (if spacing is the negative of
    the em-size (sum of ascent and descent) then a default value will be used).
  <DT>
    AutoKern(spacing,threshold[,kernfile])
  <DD>
    (AutoKern doesn't work well in general)<BR>
    Guesses at kerning pairs by looking at all selected glyphs, or if a kernfile
    is specified, FontForge will read the kern pairs out of the file.
  <DT>
    SetKern(ch2,offset)
  <DD>
    Sets the kern between any selected glyphs and the glyph ch2 to be offset.
    The first argument may be specified as in Select(), the second is an integer
    representing the kern offset.
  <DT>
    RemoveAllKerns()
  <DD>
    Removes all kern pairs and classes from the current font.
  <DT>
    SetVKern(ch2,offset)
  <DD>
    Sets the kern between any selected glyphs and the glyph ch2 to be offset.
    The first argument may be specified as in Select(), the second is an integer
    representing the kern offset.
  <DT>
    VKernFromHKern()
  <DD>
    Removes all vertical kern pairs and classes from the current font, and then
    generates new vertical kerning pairs by copying the horizontal kerning data
    for a pair of glyphs to the vertically rotated versions of those glyphs.
  <DT>
    RemoveAllVKerns()
  <DD>
    Removes all vertical kern pairs and classes from the current font.
  <DD>
      <HR>
  <DT>
    MMInstanceNames()
  <DD>
    Returns an array containing the names of all instance fonts in a multi master
    set.
  <DT>
    MMAxisNames()
  <DD>
    Returns an array containing the names of all axes in a multi master set.
  <DT>
    MMAxisBounds(axis)
  <DD>
    Axis is an integer less than the number of axes in the mm font. Returns an
    array containing the lower bound, default value and upper bound. Note each
    value is multiplied by 65536 (because they need not be integers on the mac,
    and ff doesn't support real values).
    <P>
    (The default value is a GX Var concept. FF simulates a reasonable value for
    true multiple master fonts).
  <DT>
    MMWeightedName()
  <DD>
    Returns the name of the weighted font in a multi master set.
  <DT>
    MMChangeInstance(instance)
  <DD>
    Where instance is either a font name or a small integer. If passed a string
    FontForge searches through all fonts in the multi master font set (instance
    fonts and the weighted font) and changes the current font to the indicated
    one. If passed a small integer, then -1 indicates the weighted font and values
    between [0,$mmcount) represent that specific instance in the font set.
  <DT>
    MMChangeWeight(weights)
  <DD>
    Weights is an array of integers, one for each axis. Each value should be
    65536 times the desired value (to deal with mac blends which tend to be small
    real numbers). This command changes the current multiple master font to have
    a different default weight, and sets that to be the current instance.
  <DT>
    MMBlendToNewFont(weights)
  <DD>
    Weights is an array of integers, one for each axis. Each value should be
    65536 times the desired value (to deal with mac blends which tend to be small
    real numbers). This command creates a completely new font by blending the
    mm font and sets the current font to the new font.
  <DT>
      <HR>
  <DT>
    CIDChangeSubFont(new-sub-font-name)
  <DD>
    If the current font is a cid keyed font, this command changes the active
    sub-font to be the one specified (the string should be the postscript FontName
    of the subfont)
  <DT>
    CIDSetFontNames(fontname[,family[,fullname[,weight[,copyright-notice]]]])
  <DD>
    Sets various postscript names associated with the top level cid font. If
    a name is omitted (or is the empty string) it will not be changed. (this
    is just like SetFontNames except it works on the top level cid font rather
    than the current font).
  <DT>
    CIDFlatten()
  <DD>
    Flattens a cid-keyed font.
  <DT>
    CIDFlattenByCMap(cmap-filename)
  <DD>
    Flattens a cid-keyed font, producing a font encoded with the result of the
    CMAP file.
  <DT>
    ConvertToCID(registry, ordering, supplement)
  <DD>
    Converts current font to a CID-keyed font using given registry, ordering
    and supplement. registry and ordering must be strings, supplement must be
    a integer.
  <DT>
    ConvertByCMap(cmapfilename)
  <DD>
    Converts current font to a CID-keyed font using specified CMap file. cmapfilename
    must be a path name of a file conforming Adobe CMap File Format. 
      <HR>
  <DT>
    CharCnt()
  <DD>
    Returns the number of glyphs in the current font
  <DT>
    InFont(arg)
  <DD>
    Returns whether the argument is in the font. The argument may be an integer
    in which case true is returned if the value is &gt;= 0 and &lt; total number
    of glyphs in the font. Otherwise if the argument is a unicode code point
    or a postscript glyph name, true is returned if that glyph is in the font.
  <DT>
    WorthOutputting(arg)
  <DD>
    Arg is as above. This returns true if the glyph contains any splines, references
    or has had its width set.
  <DT>
    CharInfo(str)<BR>
    CharInfo("Kern",glyph-spec)<BR>
    CharInfo("VKern",glyph-spec)<BR>
    CharInfo(str,script,lang,tag)
  <DD>
    There must be exactly one glyph selected in the font, and this returns
    information on it. The information returned depends on str with the obvious
    meanings:
    <UL>
      <LI>
	"Name" returns the glyph's name
      <LI>
	"Unicode" returns the glyph's unicode encoding
      <LI>
	"Encoding" returns the glyph's encoding in the current font
      <LI>
	"Width" returns the glyph's width
      <LI>
	"VWidth" returns the glyph's Vertical width
      <LI>
	"LBearing" returns the glyph's left side bearing
      <LI>
	"RBearing" returns the glyph's right side bearing
      <LI>
	"BBox" returns a 4 element array containing [minimum-x-value, minimum-y-value,
	maximum-x-value, maximum-y-value] of the glyph.
      <LI>
	"Kern" (there must be a second argument here which specifies another glyph
	as in Select()) Returns the kern offset between the two glyphs (or 0 if none).
      <LI>
	"VKern" (there must be a second argument here which specifies another glyph
	as in Select()) Returns the vertical kern offset between the two glyphs (or
	0 if none).
      <LI>
	"Xextrema" (there must be a second argument here which specifies the vertical
	position) Returns a two element array containing the minimum and maximum
	horizontal positions on the contours of the glyph at the given vertical position.
	If the position is beyond the glyph's bounding box the minimum value will
	be set to 1 and the max to 0 (ie. max&lt;min which is impossible).
      <LI>
	"Yextrema" (there must be a second argument here which specifies the horizontal
	position) Returns a two element array containing the minimum and maximum
	vertical positions on the contours of the glyph at the given horizontal position.
	If the position is beyond the glyph's bounding box the minimum value will
	be set to 1 and the max to 0 (ie. max&lt;min which is impossible).
      <LI>
	"Color" returns the glyph's color as a 24bit rgb value (or -2 if no color
	has been assigned to the glyph).
      <LI>
	"Comment" returns the glyph's comment (it will be converted from unicode
	into the default encoding).
      <LI>
	"Changed" returns whether the glyph has been changed since the last save
	or load.
      <LI>
	"DontAutoHint" returns the status of the "Don't AutoHint" flag.
      <LI>
	"Position" takes three additional arguments, a script, a language and a tag
	(all 4 character strings) and returns whether the glyph has a Position alternate
	with that tag.
      <LI>
	"Pair" takes three additional arguments, a script, a language and a tag (all
	4 character strings) and returns whether the glyph has a Pairwise positioning
	alternate with that tag.
      <LI>
	"Substitution" takes three additional arguments, a script, a language and
	a tag (all 4 character strings) and returns the name of the Simple Substitution
	alternate with that tag (or a null string if there is none).
      <LI>
	"AltSubs" takes three additional arguments, a script, a language and a tag
	(all 4 character strings) and returns a space separated list of the names
	of all alternate substitutions with that tag (or a null string if there is
	none).
      <LI>
	"MultSubs" takes three additional arguments, a script, a language and a tag
	(all 4 character strings) and returns a space separated list of all the names
	of all glyphs this glyph gets decomposed into with that tag (or a null string
	if there is none).
      <LI>
	"Ligature" takes three additional arguments, a script, a language and a tag
	(all 4 character strings) and returns a space separated list of the names
	of all components with that tag (or a null string if there is none).
      <LI>
	"GlyphIndex" returns the index of the current glyph in the ttf 'glyf' table,
	or -1 if it has been created since. This value may change when a
	truetype/opentype font is generated (to the index in the generated font).
    </UL>
    <P>
    Examples:
    <BLOCKQUOTE>
      <PRE>Select("A")
lbearing = CharInfo("LBearing")
kern = CharInfo("Kern","O")
Select(0u410)
SetLBearing(lbearing)
SetKern(0u41e,kern)
Select("a")
verta = CharInfo("Substitution","*","dflt","vrt2")
</PRE>
    </BLOCKQUOTE>
</DL>
<P>
  <HR>
<H2>
  <A NAME="Example">Example</A>s
</H2>
<UL>
  <LI>
    <A HREF="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/pfaedit/pfaedit/test/">FontForge's
    testsuite</A> (such as it is)
  <LI>
    <A HREF="scripts/">Directory of donated scripts</A>
  <LI>
    Scripts used in other projects
    <UL>
      <LI>
	<A HREF="http://sourceforge.net/projects/x-symbol/">x-symbol</A>
    </UL>
</UL>
<H3>
  Example 1:
</H3>
<BLOCKQUOTE>
  <PRE>#Set the color of all selected glyphs to be yellow
#designed to be run within an interactive fontforge session.
foreach
  SetCharColor(0xffff00)
endloop
</PRE>
</BLOCKQUOTE>
<H3>
  Example 2:
</H3>
<BLOCKQUOTE>
  <PRE>#!/usr/local/bin/fontforge
#Take a Latin font and apply some simple transformations to it
#prior to adding cyrillic letters.
#can be run in a non-interactive fontforge session.
Open($1);
Reencode("KOI8-R");
Select(0xa0,0xff);
//Copy those things which look just like latin
BuildComposit();
BuildAccented();

//Handle Ya which looks like a backwards "R"
Select("R");
Copy();
Select("afii10049");
Paste();
HFlip();
CorrectDirection();
Copy();
Select(0u044f);
Paste();
CopyFgToBg();
Clear();

//Gamma looks like an upside-down L
Select("L");
Copy();
Select(0u0413);
Paste();
VFlip();
CorrectDirection();
Copy();
Select(0u0433);
Paste();
CopyFgToBg();
Clear();

//Prepare for editing small caps K, etc.
Select("K");
Copy();
Select(0u043a);
Paste();
CopyFgToBg();
Clear();

Select("H");
Copy();
Select(0u043d);
Paste();
CopyFgToBg();
Clear();

Select("T");
Copy();
Select(0u0442);
Paste();
CopyFgToBg();
Clear();

Select("B");
Copy();
Select(0u0432);
Paste();
CopyFgToBg();
Clear();

Select("M");
Copy();
Select(0u043C);
Paste();
CopyFgToBg();
Clear();

Save($1:r+"-koi8-r.sfd");
Quit(0);
</PRE>
</BLOCKQUOTE>
<H2>
  The <A NAME="Execute">Execute</A> Script dialog
</H2>
<P>
This dialog allows you to type a script directly in to FontForge and then
run it. Of course the most common case is that you'll have a script file
somewhere that you want to execute, so there's a button [Call] down at the
bottom of the dlg. Pressing [Call] will bring up a file picker dlg looking
for files with the extension *.pe (you can change that by typing a wildcard
sequence and pressing the [Filter] button). After you have selected your
script the appropriate text to text to invoke it will be placed in the text
area.
<P>
The current font of the script will be set to whatever font you invoked it
from.
<H2>
  The Scripts <A NAME="menu">Menu</A>
</H2>
<P>
You can use the preference dialog to create a list of frequently used scripts.
Invoke <A HREF="prefs.html#scripts">File-&gt;Preferences</A> and select the
Scripts tag. In this dialog are ten possible entries, each one should have
a name (to be displayed in the menu) and an associated script file to be
run.
<P>
After you have set up your preferences you can invoke scripts from the font
view, either directly from the menu (File-&gt;Scripts-&gt;&lt;your name&gt;)
or by a hot key. The first script you added will be invoked by Cnt-Alt-1,
then second by Cnt-Alt-2, and the tenth by Cnt-Alt-0.
<P>
The current font of the script will be set to whatever font you invoked it
from.
<P>
<P ALIGN=Center>
-- <A HREF="HotKeys.html">Prev</A> -- <A HREF="overview.html">TOC</A> --
<A HREF="PfaEdit-TeX.html">Next</A> --
</BODY></HTML>
