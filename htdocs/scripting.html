<HTML>
<HEAD>
  <!-- Created with AOLpress/2.0 -->
  <!-- AP: Created on: 18-Jan-2002 -->
  <!-- AP: Last modified: 16-Feb-2002 -->
  <TITLE>Writing scripts to change fonts in PfaEdit</TITLE>
</HEAD>
<BODY>
<H1 ALIGN=Center>
  Writing scripts to change fonts in PfaEdit
</H1>
<P>
PfaEdit includes an interpreter so you can write scripts to modify fonts.
<UL>
  <LI>
    <A HREF="#Starting">Starting a script</A>
  <LI>
    <A HREF="#Language">Scripting language</A>
    <UL>
      <LI>
	<A HREF="#variables">Built in variables</A>
      <LI>
	<A HREF="#procedures">Built in procedures</A>
      <LI>
	<A HREF="#Example">Example</A>
    </UL>
  <LI>
    <A HREF="scripting.html#Execute">The Execute Script dialog</A>
  <LI>
    <A HREF="#menu">The Scripts menu</A>
</UL>
<H2>
  <A NAME="Starting">Starting scripts</A>
</H2>
<P>
If you start pfaedit with a script on the command line it will not put up
any windows and it will exit when the script is done.
<BLOCKQUOTE>
  <PRE>$ pfaedit -script scriptfile.pe {fontnames}
</PRE>
</BLOCKQUOTE>
<P>
PfaEdit can also be used as an interpreter that the shell will automatically
pass scripts to. If you a mark your script files as executable<BR>
<CODE>&nbsp; &nbsp; $ chmod +x scriptfile.pe</CODE><BR>
and begin each one with the line<BR>
<CODE>&nbsp; &nbsp; #!/usr/local/bin/pfaedit</CODE><BR>
(or wherever pfaedit happens to reside on your system) then you can invoke
the script just by typing<BR>
<CODE>&nbsp; &nbsp; $ scriptfile.pe {fontnames}</CODE>
<P>
You can also start a script from within PfaEdit with File-&gt;Execute Script,
and you can use the Preference Dlg to define a set of frequently used scripts
which can be invoked directly by menu.
<P>
The scripting language provides access to much of the functionality found
in the font view's menus. It does not currently (and probably never will)
provide access to everything. (If you find a lack let me know, I may put
it in for you). It does not provide commands for building up a character
out of splines, instead it allows you to do high level modifications to
characters.
<P>
In general I envision this as being useful for things like taking a latin
font and extending it to contain cyrillic characters. So the script might:
<UL>
  <LI>
    Reencode the font
  <LI>
    Place a reference to Latin "A" at Cyrillic "A"
  <LI>
    Copy Latin "R" to Cyrillic "YA"
  <LI>
    Flip "YA" horizontally
  <LI>
    Correct its direction
  <LI>
    ... and so forth
</UL>
<H2>
  Scripting <A NAME="Language">Language</A>
</H2>
<P>
The syntax is rather like a mixture of C and shell commands. Every file
corresponds to a procedure. As in a shell script arguments passed to the
file are identified as $1, $2, ... $n. $0 is the file name itself. $argc
gives the number of arguments. $argv[&lt;expr&gt;] provides array access
to the arguments.
<P>
Terms can be
<UL>
  <LI>
    A variable name (like "$1" or "i" or "@fontvar" or "_global")<BR>
    The scope of the variable depends on the initial character of its name.
    <UL>
      <LI>
	A '$' signifies that it is a built-in variable. The user cannot create any
	new variables beginning with '$'. Some, but not all, of these may be assigned
	to.
      <LI>
	A '_' signifies that the variable is global, it is always available. You
	can use these to store context across different script files (or to access
	data within nested script files).
      <LI>
	A '@' signifies that the variable is associated with the font. Any two scripts
	looking at the same font will have access to the same variables.
      <LI>
	A variable which begins with a letter is a local variable. It is only meaningful
	within the current script file. Nested script files may have different variables
	with the same names.
    </UL>
  <LI>
    an integer expressed in decimal, hex or octal
  <LI>
    a unicode code point (which has a prefix of "0u" or "0U" and is followed
    by a string of hex digits. This is only used by the select command.
  <LI>
    A string which may be enclosed in either double or single quotes
  <LI>
    a procedure to call or file to invoke.
  <LI>
    an expression within parentheses
</UL>
<P>
There are three different comments supported:
<UL>
  <LI>
    Starting with a "#" character and proceding to end of line
  <LI>
    Starting with "//" and proceding to end of line
  <LI>
    Starting with "/*" and proceding to "*/"
</UL>
<P>
Expressions are similar to those in C, a few operators have been omitted,
a few added from shell scripts. Operator precedence has been simplified slightly.
So operators (and their precedences) are:
<UL>
  <LI>
    unary operators (+, -, !, ~, ++ (prefix and postfix), --(prefix and postfix),
    () (procedure call), [] (array index), :h, :t, :r, :e<BR>
    Most of these are as expected in C, the last four are borrowed from shell
    scripts and are applied to strings
    <UL>
      <LI>
	:h gives the head (directory) of a pathspec
      <LI>
	:t gives the tail (filename) of a pathspec
      <LI>
	:r gives the pathspec without the extension (if any)
      <LI>
	:e gives the extension
    </UL>
  <LI>
    *, /, % (binary multiplicative operators)
  <LI>
    +, - (binary arithmetric operators)<BR>
    If the first operand of + is a string then + will be treated as concatenation
    rather than addition. If the second operand is a number it will be converted
    to a string (decimal representation) and then concatenated.
  <LI>
    ==, !=, &gt;, &lt;, &gt;=, &lt;= (comparison operators, may be applied to
    either two integers or two strings)
  <LI>
    &amp;&amp;, &amp; (logical and, bitwise and. (logical and will do short circuit
    evaluation))
  <LI>
    ||, |, ^ (logical or, bitwise or, bitwise exclusive or (logical or will do
    short circuit evaluation))
  <LI>
    =, +=, -=, *=, /=, %= (assignment operators as in C. The += will act as
    concatenation if the first operand is a string.)
</UL>
<P>
Note there is no comma operator, and no "?:" operator. The precedence of
"and" and "or" has been simplified, as has that of the assignment operators.
<P>
Procedure calls may be applied either to a name token, or to a string. If
the name or string is recognized as one of PfaEdit's internal procedures
it will be executed, otherwise it will be assumed to be a filename containing
another pfaedit script file, this file will be invoked (since filenames can
contain characters not legal in name tokens it is important to allow general
strings to specify filenames). If the procedure name does not contain a directory
then it is assumed to be in the same directory as the current script file.
<P>
Arrays are passed by reference, strings and integers are passed by value.
<P>
Variables may be created by assigning a value to them (only with the "="),
so:<BR>
<CODE>&nbsp; &nbsp; i=3</CODE><BR>
could be used to define "i" as a variable. Variables are limited in scope
to the current file, they will not be inherited by called procedures.
<P>
A statement may be
<UL>
  <LI>
    an expression
  <LI>
    <CODE>if ( expression )<BR>
    &nbsp; &nbsp; statements<BR>
    {elseif ( expression )<BR>
    &nbsp; &nbsp; statements}<BR>
    [else<BR>
    &nbsp; &nbsp; statements]<BR>
    endif</CODE>
  <LI>
    <CODE>while ( expression )<BR>
    &nbsp; &nbsp; statements<BR>
    endloop</CODE>
  <LI>
    <CODE>return [ expression ]</CODE>
  <LI>
    <CODE>shift</CODE>
</UL>
<P>
As with C, non-zero expressions are defined to be true.<BR>
A return statement may be followed by a return value (the expression) or
a procedure may return nothing (void).<BR>
The shift statement is stolen from shell scripts and shifts all arguments
down by one. (argument 0, the name of the script file, remains unchanged.<BR>
Statements are terminated either by a new line or a semicolon.
<P>
Trivial example:
<BLOCKQUOTE>
  <PRE>i=0;	#semicolon is not needed here, but it's ok
while ( i&lt;3 )
   if ( i==1 /* pointless comment */ )
	Print( "Got to one" )	// Another comment
   endif
   ++i
endloop
</PRE>
</BLOCKQUOTE>
<P>
PfaEdit maintains the concept of a "current font" almost all commands refer
only to the current font (and require that there be a font). If you start
a script with File-&gt;Execute Script, the font you were editing will be
current, otherwise there will be no initial current font. The Open(), New()
and Close() commands all change the current font. PfaEdit also maintains
a list of all fonts that are currently open. This list is in no particular
order. The list starts with $firstfont.
<P>
Similarly when working with cid keyed fonts, PfaEdit works in the "current
sub font", and most commands refer to this font. The CIDChangeSubFont() command
can alter that.
<P>
All builtin <A NAME="variables">variables</A> begin with "$", you may not
create any variables that start with "$" yourself (though you may assign
to (some) already existing ones)
<UL>
  <LI>
    <CODE>$0 </CODE>the current script filename
  <LI>
    <CODE>$1 </CODE>the first argument to the script file
  <LI>
    <CODE>$2 </CODE>the second argument to the script file
  <LI>
    ...
  <LI>
    <CODE>$argc</CODE> the number of arguments passed to the script file (this
    will always be at least 1 as $0 is always present)
  <LI>
    <CODE>$argv </CODE>allows you to access the array of all the arguments
  <LI>
    <CODE>$curfont </CODE>the name of the filename in which the current font
    resides
  <LI>
    <CODE>$firstfont </CODE>the name of the filename of the font which is first
    on the font list
  <LI>
    <CODE>$nextfont </CODE>the name of the filename of the font which follows
    the current font on the list (or the empty string if the current font is
    the last one on the list)
  <LI>
    <CODE>$fontname</CODE> the name contained in the postscript FontName field
  <LI>
    <CODE>$familyname </CODE>the name contained in the postscript FamilyName
    field
  <LI>
    <CODE>$fullname </CODE>the name contained in the postscript FullName field
  <LI>
    <CODE>$weight </CODE>the name contained in the postscript Weight field
  <LI>
    <CODE>$copyright </CODE>the name contained in the postscript Notice field
  <LI>
    <CODE>$cidfontname </CODE>returns the fontname of the top-level cid-keyed
    font (or the empty string if there is none)<BR>
    Can be used to detect if this is a cid keyed font.
  <LI>
    <CODE>$cidfamilyname, $cidfullname, $cidweight, $cidcopyright </CODE>similar
    to above
  <LI>
    <CODE>$italicangle </CODE>the value of the postscript italic angle field
  <LI>
    <CODE>$curcid </CODE>returns the fontname of the current font
  <LI>
    <CODE>$firstcid </CODE>returns the fontname of the first font within this
    cid font
  <LI>
    <CODE>$nextcid </CODE>returns the fontname of the next font within this cid
    font (or the empty string if the current sub-font is the last)
  <LI>
    <CODE>$trace</CODE> if this is set to one then PfaEdit will trace each procedure
    call.
</UL>
<P>
The following example will perform an action on all loaded fonts:
<BLOCKQUOTE>
  <PRE>file = $firstfont
while ( file != "" )
   Open(file)
   /* Do Stuff */
   file = $nextfont
endloop
</PRE>
</BLOCKQUOTE>
<P>
The built in <A NAME="procedures">procedures</A> are very similar to the
menu items with the same names.
<DL>
  <DT>
    Print(arg1,arg2,arg3,...)
  <DD>
    This corresponds to no menu item. It will print all of its arguments to stdout.
    It can execute with no current font.
  <DT>
    Error(str)
  <DD>
    Prints out str as an error message and aborts the current script
  <DT>
    AskUser(question[,default-answer])
  <DD>
    Asks the user the question and returns an answer. A default-answer may be
    specified too.
  <DT>
    Array(size)
  <DD>
    Allocates an array of the indicated size.
    <BLOCKQUOTE>
      <PRE>a = Array(10)
i = 0;
while ( i&lt;10 )
   a[i] = i++
endloop
a[3] = "string"
a[4] = Array(10)
a[4][0] = "Nested array";
</PRE>
    </BLOCKQUOTE>
  <DT>
    Strsub(str,start[,end])
  <DD>
    Returns a substring of the string argument. The substring beings at position
    indexed by start and ends at the position indexed by end (if end is omitted
    the end of the string will be used). Thus <CODE>Strsub("abcdef",2,2) == "b"
    </CODE>and <CODE>Strsub("abcdef",2) == "bcdef"</CODE>
  <DT>
    Strlen(str)
  <DD>
    Returns the length of the string.
  <DT>
    Strstr(haystack,needle)
  <DD>
    Returns the index of the first occurance of the string needle within the
    string haystack (or -1 if not found).
  <DT>
    Strrstr(haystack,needle)
  <DD>
    Returns the index of the last occurance of the string needle within the string
    haystack (or -1 if not found).
  <DT>
    Strcasestr(haystack,needle)
  <DD>
    Returns the index of the first occurance of the string needle within the
    string haystack ignoring case in the search (or -1 if not found).
  <DT>
    Strcasecmp(str1,str2)
  <DD>
    Compares the two strings ignoring case, returns zero if the two are equal,
    a negative number if str1&lt;str2 and a positive number if str1&gt;str2
  <DT>
    Strtol(str[,base])
  <DD>
    Parses as much of str as possible and returns the integer value it represents.
    A second argument may be used to specify the base of the conversion (it defaults
    to 10). Behavior is as for strtol(3).
  <DT>
    Strskipint(str[,base])
  <DD>
    Parses as much of str as possible and returns the offset to the first character
    that could not be parsed. 
      <HR>
  <DT>
    Open(filename)
  <DD>
    This makes the font named by filename be the current font. If filename has
    not yet been loaded into memory it will be loaded now. It can execute with
    no current font.
  <DT>
    New()
  <DD>
    This creates a new font. It can execute with no current font.
  <DT>
    Close()
  <DD>
    This frees up any memory taken up by the current font and drops it off the
    list of loaded fonts. After this executes there will be no current font.
  <DT>
    Save([filename])
  <DD>
    If no filename is specified then this saves the current font back into its
    sfd file (if the font has no sfd file then this is an error). With one argument
    it executes a SaveAs command, saving the current font to that filename.
  <DT>
    Generate(filename[,bitmaptype])
  <DD>
    Generates a font. The type of font is determined by the extension of the
    filename. If present, bitmaptype may be one of:
    <UL>
      <LI>
	bdf
      <LI>
	ms (for EBDT table in truetype)
      <LI>
	apple (for bdat table in truetype)
      <LI>
	sbit (for bdat table in truetype without any outline font)
      <LI>
	gdf
      <LI>
	bin (for nfnt in macbinary)
      <LI>
	dfont (for nfnt in dfont)
      <LI>
	"" for no bitmaps
    </UL>
    <P>
    If you do not wish to generate an outline font then give the filename the
    extension of ".bdf".
  <DT>
    Import
  <DD>
    Either imports a bitmap font into the database, or imports background image[s]
    into various characters. There may be one or two arguments. The first must
    be a string representing a filename. The extension of the file determines
    how the import procedes. If present the second argument must be an integer,
    if the first argument is a bitmap font then the second argument controls
    whether it is imported into the bitmap list (0) or to fill up the backgrounds
    of characters (1).
    <UL>
      <LI>
	If the extension is ".bdf" then a bdf font will be imported
      <LI>
	If the extension is ".pcf" then a pcf font will be imported.
      <LI>
	If the extension is ".ttf" then the EBDT or bdat table of the ttf file will
	be searched for bitmap fonts
      <LI>
	If the extension is "pk" then a metafont pk (bitmap font) file will be import
	and by default placed in the background
      <LI>
	Otherwise if the extension is an image extension, and any loaded images will
	be placed in the background.
	<UL>
	  <LI>
	    If the filename contains a "*" then it should be a recognized template in
	    which case all images which match that template will be loaded appropriately
	    and stored in the background
	  <LI>
	    Otherwise there may be several filenames (seperated by semicolons), the first
	    will be placed in the background of the first selected character, the second
	    into the background of the second selected character, ...
	</UL>
      <LI>
	Finally if the extension is "eps" then an encapsulated postscript file will
	be merged into the foreground. The file may be specified as for images (except
	the extension should be "eps" rather than an image extension). PfaEdit is
	very limitted in its ability to read eps files.
    </UL>
  <DT>
    Quit(status)
  <DD>
    Causes PfaEdit to exit with the given status. It can execute with no current
    font. 
      <HR>
  <DT>
    Cut
  <DD>
    Makes a copy of all selected characters and saves it in the clipboard, then
    clears out the selected characters
  <DT>
    Copy
  <DD>
    Makes a copy of all selected characters.
  <DT>
    CopyReference
  <DD>
    Makes references to all selected characters and stores them in the clipboard.
  <DT>
    CopyWidth
  <DD>
    Stores the widths of all selected characters in the clipboard
  <DT>
    CopyVWidth
  <DD>
    Stores the vertical widths of all selected characters in the clipboard
  <DT>
    CopyLBearing
  <DD>
    Stores the left side bearing of all selected characters in the clipboard
  <DT>
    CopyRBearing
  <DD>
    Stores the right side bearing of all selected characters in the clipboard
  <DT>
    Paste
  <DD>
    Copies the clipboard into the current font (removing what was there before)
  <DT>
    PasteInto
  <DD>
    Copies the clipboard into the current font (merging with what was there before)
  <DT>
    Clear
  <DD>
    Clears out all selected characters
  <DT>
    ClearBackground
  <DD>
    Clears the background of all selected characters
  <DT>
    CopyFgToBd
  <DD>
    Copies all foreground splines into the background in all selected characters
  <DT>
    UnlinkReference
  <DD>
    Unlinks all references within all selected characters
  <DT>
    SelectAll
  <DD>
    Selects all characters
  <DT>
    SelectNone
  <DD>
    Deselects all characters
  <DT>
    Select(arg1, arg2, ...)
  <DD>
    This clears out the current selection, then for each pair of arguments it
    selects all characters between (inclusive) the bounds specified by the pair.
    If there is a final singleton argument then that single character will be
    selected. An argument may be specified by:
    <UL>
      <LI>
	an integer which specifies the location in the current font's encoding
      <LI>
	a postscript unicode name which gets mapped into the current font's encoding
      <LI>
	a unicode code point (0u61) which gets mapped to the current font's encoding
    </UL>
  <DT>
    SelectMore(arg1, arg2, ...)
  <DD>
    The same as the previous command except that it does not clear the selection,
    so it extends the current selection. 
      <HR>
  <DT>
    Reencode(encoding-name)
  <DD>
    Reencodes the current font into the given encoding which may be:<BR>
    iso8859-1, isolatin1, latin1, iso8859-2, latin2, iso8859-3, latin3, iso8859-4,
    latin4, iso8859-5, iso8859-6, iso8859-7, iso8859-8, iso8859-9, iso8859-10,
    iso8859-13, iso8859-14, iso8859-15, latin0, koi8-r, AdobeStandardEncoding,
    win, mac, wansung, big5, johab, jis208, unicode, iso10646-1 (or one of the
    user defined encodings).
  <DT>
    SetCharCnt(cnt)
  <DD>
    Sets the number of characters in the font.
  <DT>
    SetFontNames(fontname[,family[,fullname[,weight[,copyright-notice]]]])
  <DD>
    Sets various postscript names associated with a font. If a name is omitted
    (or is the empty string) it will not be changed.
  <DT>
    SetItalicAngle(angle)
  <DD>
    Sets the postscript italic angle field appropriately.
  <DT>
    SetCharName(name[,set-from-name-flag])
  <DD>
    Sets the currently selected character to have the given name. If
    set-from-name-flag is present and is true then it will also set the unicode
    value and the ligature string to match the name.
  <DT>
    SetUnicodeValue(uni[,set-from-value-flag])
  <DD>
    Sets the currently selected character to have the given unicode value. If
    set-from-value-flag is present and is true then it will also set the name
    and the ligature string to match the value.
  <DT>
    Transform(t1,t2,t3,t4,t5,t6)
  <DD>
    Each argument will be divided by 100. and then all selected characters will
    be transformed by this matrix
  <DT>
    HFlip([about-x])
  <DD>
    All selected characters will be horizontally flipped about the vertical line
    through x=about-x. If no argument is given then all selected characters will
    be flipped about their central point.
  <DT>
    VFlip([about-y])
  <DD>
    All selected characters will be vertically flipped about the horizontal line
    through y=about-y. If no argument is given then all selected characters will
    be flipped about their central point.
  <DT>
    Rotate(angle[,ox,oy])
  <DD>
    Rotates all selected character the specified number of degrees. If the last
    two args are specified they provide the origin of the rotation, otherwise
    the center of the character is used.
  <DT>
    Scale(factor[,yfactor][,ox,oy])
  <DD>
    All selected characters will be scaled (scale factors are in percent)
    <UL>
      <LI>
	with one argument they will be scaled uniformly about the character's center
	point
      <LI>
	with two arguments the first specifies the scale factor for x, the second
	for y. Again scaling will be about the center point
      <LI>
	with three arguments they will be scaled uniformly about the specified center
      <LI>
	with four arguments they will be scaled differently about the specified center
    </UL>
  <DT>
    Skew(angle[,ox,oy])
  <DD>
    All selected characters will be skewed by the given angle.
  <DT>
    Move(delta-x,delta-y)
  <DD>
    All selected characters will have their points moved the given amount.
  <DT>
    ExpandStroke(width)<BR>
    ExpandStroke(width,caligraphic-angle)<BR>
    ExpandStroke(width,line cap, line join)
  <DD>
    In the first format a line cap of "butt" and line join of "round" are implied.
  <DT>
    RemoveOverlap()
  <DD>
    Does the obvious.
  <DT>
    Simplify()
  <DD>
    Does the obvious.
  <DT>
    AddExtrema()
  <DD>
  <DT>
    RoundToInt()
  <DD>
  <DT>
    AutoTrace()
  <DD>
  <DT>
    CorrectDirection()
  <DD>
  <DT>
    BuildComposit()
  <DD>
  <DT>
    BuildAccented()
  <DD>
  <DT>
    MergeFonts(other-font-name)
  <DD>
      <HR>
  <DT>
    AutoHint()
  <DD>
  <DT>
    SetWidth(width)
  <DD>
  <DT>
    SetVWidth(vertical-width)
  <DD>
  <DT>
    SetLBearing(lbearing)
  <DD>
  <DT>
    SetRBearing(rbearing)
  <DD>
  <DT>
    SetKern(ch2,offset)
  <DD>
    Sets the kern between any selected characters and the character ch2 to be
    offset. The first argument may be specified as in Select(), the second is
    an integer representing the kern offset.
  <DD>
      <HR>
  <DT>
    CIDChangeSubFont(new-sub-font-name)
  <DD>
    If the current font is a cid keyed font, this command changes the active
    sub-font to be the one specified (the string should be the postscript FontName
    of the subfont)
  <DT>
    CIDSetFontNames(fontname[,family[,fullname[,weight[,copyright-notice]]]])
  <DD>
    Sets various postscript names associated with the top level cid font. If
    a name is omitted (or is the empty string) it will not be changed. (this
    is just like SetFontNames except it works on the top level cid font rather
    than the current font). 
      <HR>
  <DT>
    CharCnt()
  <DD>
    Returns the number of characters in the current font
  <DT>
    InFont(arg)
  <DD>
    Returns whether the argument is in the font. The argument may be an integer
    in which case true is returned if the value is &gt;= 0 and &lt; total number
    of characters in the font. Otherwise if the argument is a unicode code point
    or a postscript character name, true is returned if that character is in
    the font.
  <DT>
    WorthOutputting(arg)
  <DD>
    Arg is as above. This returns true if the character contains any splines,
    references or has had its width set.
  <DT>
    CharInfo(str)
  <DD>
    There must be exactly one character selected in the font, and this returns
    information on it. The information returned depends on str with the obvious
    meanings:
    <UL>
      <LI>
	"Name" returns the character's name
      <LI>
	"Unicode" returns the character's unicode encoding
      <LI>
	"Encoding" returns the character's encoding in the current font
      <LI>
	"Width" returns the character's width
      <LI>
	"VWidth" returns the character's Vertical width
      <LI>
	"LBearing" returns the character's left side bearing
      <LI>
	"RBearing" returns the character's right side bearing
      <LI>
	"Kern" (there must be a second argument here which specifies another character
	as in Select()) Returns the kern offset between the two characters (or 0
	if none).
    </UL>
    <P>
    Examples:
    <BLOCKQUOTE>
      <PRE>Select("A")
lbearing = CharInfo("LBearing")
kern = CharInfo("Kern","O")
Select(0u410)
SetLBearing(lbearing)
SetKern(0u41e,kern)
</PRE>
    </BLOCKQUOTE>
</DL>
<P>
  <HR>
<H3>
  <A NAME="Example">Example</A>:
</H3>
<BLOCKQUOTE>
  <PRE>#!/usr/local/bin/pfaedit
#Take a Latin font and apply some simple transformations to it
#prepriotory to adding cyrillic letters.
Open($1);
Reencode("KOI8-R");
Select(0xa0,0xff);
//Copy those things which look just like latin
BuildComposit();
BuildAccented();

//Handle Ya which looks like a backwards "R"
Select("R");
Copy();
Select("afii10049");
Paste();
HFlip();
CorrectDirection();
Copy();
Select(0u044f);
Paste();
CopyFgToBg();
Clear();

//Gamma looks like an upside-down L
Select("L");
Copy();
Select(0u0413);
Paste();
VFlip();
CorrectDirection();
Copy();
Select(0u0433);
Paste();
CopyFgToBg();
Clear();

//Prepare for editing small caps K, etc.
Select("K");
Copy();
Select(0u043a);
Paste();
CopyFgToBg();
Clear();

Select("H");
Copy();
Select(0u043d);
Paste();
CopyFgToBg();
Clear();

Select("T");
Copy();
Select(0u0442);
Paste();
CopyFgToBg();
Clear();

Select("B");
Copy();
Select(0u0432);
Paste();
CopyFgToBg();
Clear();

Select("M");
Copy();
Select(0u043C);
Paste();
CopyFgToBg();
Clear();

Save($1:r+"-koi8-r.sfd");
Quit(0);
</PRE>
</BLOCKQUOTE>
<H2>
  The <A NAME="Execute">Execute</A> Script dialog
</H2>
<P>
This dialog allows you to type a script directly in to PfaEdit and then run
it. Of course the most common case is that you'll have a script file somewhere
that you want to execute, so there's a button [Call] down at the bottom of
the dlg. Pressing [Call] will bring up a file picker dlg looking for files
with the extension *.pe (you can change that by typing a wildcard sequence
and pressing the [Filter] button). After you have selected your scipt the
appropriate text to text to invoke it will be placed in the text area.
<P>
The current font of the script will be set to whatever font you invoked it
from.
<H2>
  The Scripts <A NAME="menu">Menu</A>
</H2>
<P>
You can use the preference dialog to create a list of frequently used scripts.
Invoke File-&gt;Preferences and select the Scripts tag. In this dialog are
ten possible entries, each one should have a name (to be displayed in the
menu) and an associated script file to be run.
<P>
After you have set up your preferences you can invoke scripts from the font
view, either directly from the menu (File-&gt;Scripts-&gt;&lt;your name&gt;)
or by a hot key. The first script you added will be invoked by Cnt-Alt-1,
then second by Cnt-Alt-2, and the tenth by Cnt-Alt-0.
<P>
The current font of the script will be set to whatever font you invoked it
from.
<P>
<P ALIGN=Center>
-- <A HREF="cliargs.html">Prev</A> -- <A HREF="overview.html">TOC</A> --
<A HREF="faqFS.html">Next</A> --
</BODY></HTML>
